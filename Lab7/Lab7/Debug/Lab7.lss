
AVRASM ver. 2.2.8  F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\main.asm Tue Nov 29 22:43:23 2022

[builtin](2): Including file 'F:/Programs\Microchip Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m32U4def.inc'
F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\main.asm(9): Including file 'F:/Programs\Microchip Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m32U4def.inc'
F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\main.asm(1193): Including file 'F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\LCDDriver.asm'
F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\LCDDriver.asm(31): Including file 'F:/Programs\Microchip Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m32U4def.inc'
[builtin](2): Including file 'F:/Programs\Microchip Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m32U4def.inc'
F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\main.asm(9): Including file 'F:/Programs\Microchip Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m32U4def.inc'
F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\main.asm(1193): Including file 'F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\LCDDriver.asm'
F:\OSU\2022 Fall\ECE 375\Labs\Lab7\Lab7\Lab7\LCDDriver.asm(31): Including file 'F:/Programs\Microchip Studio\7.0\Packs\atmel\ATmega_DFP\1.7.374\avrasm\inc\m32U4def.inc'
                                 
                                 ;***********************************************************
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #define _M32U4DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega32U4
                                 #pragma AVRPART ADMIN PART_NAME ATmega32U4
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x87
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	PLLCSR	= 0x29
                                 .equ	PLLFRQ	= 0x32
                                 .equ	UEINT	= 0xf4	; MEMORY MAPPED
                                 .equ	UEBCHX	= 0xf3	; MEMORY MAPPED
                                 .equ	UEBCLX	= 0xf2	; MEMORY MAPPED
                                 .equ	UEDATX	= 0xf1	; MEMORY MAPPED
                                 .equ	UEIENX	= 0xf0	; MEMORY MAPPED
                                 .equ	UESTA1X	= 0xef	; MEMORY MAPPED
                                 .equ	UESTA0X	= 0xee	; MEMORY MAPPED
                                 .equ	UECFG1X	= 0xed	; MEMORY MAPPED
                                 .equ	UECFG0X	= 0xec	; MEMORY MAPPED
                                 .equ	UECONX	= 0xeb	; MEMORY MAPPED
                                 .equ	UERST	= 0xea	; MEMORY MAPPED
                                 .equ	UENUM	= 0xe9	; MEMORY MAPPED
                                 .equ	UEINTX	= 0xe8	; MEMORY MAPPED
                                 .equ	UDMFN	= 0xe6	; MEMORY MAPPED
                                 .equ	UDFNUMH	= 0xe5	; MEMORY MAPPED
                                 .equ	UDFNUML	= 0xe4	; MEMORY MAPPED
                                 .equ	UDADDR	= 0xe3	; MEMORY MAPPED
                                 .equ	UDIEN	= 0xe2	; MEMORY MAPPED
                                 .equ	UDINT	= 0xe1	; MEMORY MAPPED
                                 .equ	UDCON	= 0xe0	; MEMORY MAPPED
                                 .equ	USBINT	= 0xda	; MEMORY MAPPED
                                 .equ	USBSTA	= 0xd9	; MEMORY MAPPED
                                 .equ	USBCON	= 0xd8	; MEMORY MAPPED
                                 .equ	UHWCON	= 0xd7	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ 	TWAMR		= 0xbd	;
                                 .equ  TWCR		= 0xbc	;
                                 .equ 	TWDR		= 0xbb	;
                                 .equ 	TWAR		= 0xba 	;
                                 .equ 	TWSR		= 0xb9	;
                                 .equ 	TWBR		= 0xb8	;
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	RCCTRL	= 0x67	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	DT4	= 0xd4	; MEMORY MAPPED
                                 .equ	OCR4D	= 0xd2	; MEMORY MAPPED
                                 .equ	OCR4C	= 0xd1	; MEMORY MAPPED
                                 .equ	OCR4B	= 0xd0	; MEMORY MAPPED
                                 .equ	OCR4A	= 0xcf	; MEMORY MAPPED
                                 .equ	TCCR4E	= 0xc4	; MEMORY MAPPED
                                 .equ	TCCR4D	= 0xc3	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xc2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xc1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xc0	; MEMORY MAPPED
                                 .equ	TC4H	= 0xbf	; MEMORY MAPPED
                                 .equ	TCNT4	= 0xbe	; MEMORY MAPPED
                                 .equ	CLKSEL1	= 0xc6	; MEMORY MAPPED
                                 .equ	CLKSEL0	= 0xc5	; MEMORY MAPPED
                                 .equ	CLKSTA	= 0xc7	; MEMORY MAPPED
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; DT4 - Timer/Counter 4 Dead Time Value
                                 .equ	DT4L0	= 0	; Timer/Counter 4 Dead Time Value Bit 0
                                 .equ	DT4L1	= 1	; Timer/Counter 4 Dead Time Value Bit 1
                                 .equ	DT4L2	= 2	; Timer/Counter 4 Dead Time Value Bit 2
                                 .equ	DT4L3	= 3	; Timer/Counter 4 Dead Time Value Bit 3
                                 .equ	DT4L4	= 4	; Timer/Counter 4 Dead Time Value Bit 4
                                 .equ	DT4L5	= 5	; Timer/Counter 4 Dead Time Value Bit 5
                                 .equ	DT4L6	= 6	; Timer/Counter 4 Dead Time Value Bit 6
                                 .equ	DT4L7	= 7	; Timer/Counter 4 Dead Time Value Bit 7
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 2	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4B	= 5	; Output Compare Flag 4B
                                 .equ	OCF4A	= 6	; Output Compare Flag 4A
                                 .equ	OCF4D	= 7	; Output Compare Flag 4D
                                 
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 2	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4B	= 5	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4A	= 6	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4D	= 7	; Timer/Counter4 Output Compare D Match Interrupt Enable
                                 
                                 ; OCR4D - Timer/Counter4 Output Compare Register D
                                 .equ	OCR4D0	= 0	; Timer/Counter4 Output Compare Register Low Byte bit 0
                                 .equ	OCR4D1	= 1	; Timer/Counter4 Output Compare Register Low Byte bit 1
                                 .equ	OCR4D2	= 2	; Timer/Counter4 Output Compare Register Low Byte bit 2
                                 .equ	OCR4D3	= 3	; Timer/Counter4 Output Compare Register Low Byte bit 3
                                 .equ	OCR4D4	= 4	; Timer/Counter4 Output Compare Register Low Byte bit 4
                                 .equ	OCR4D5	= 5	; Timer/Counter4 Output Compare Register Low Byte bit 5
                                 .equ	OCR4D6	= 6	; Timer/Counter4 Output Compare Register Low Byte bit 6
                                 .equ	OCR4D7	= 7	; Timer/Counter4 Output Compare Register Low Byte bit 7
                                 
                                 ; OCR4C - Timer/Counter4 Output Compare Register C
                                 .equ	OCR4C0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4C1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4C2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4C3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4C4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4C5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4C6	= 6	; Timer/Counter4 Output Compare Register 6
                                 .equ	OCR4C7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4B - Timer/Counter4 Output Compare Register B
                                 .equ	OCR4B0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4B1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4B2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4B3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4B4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4B5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4B6	= 6	; Timer/Counter4 Output Compare Register bit 6
                                 .equ	OCR4B7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4A - Timer/Counter4 Output Compare Register A
                                 .equ	OCR4A0	= 0	; Timer/Counter4 Output Compare Register Bit 0
                                 .equ	OCR4A1	= 1	; Timer/Counter4 Output Compare Register Bit 1
                                 .equ	OCR4A2	= 2	; Timer/Counter4 Output Compare Register Low Byte Bit 2
                                 .equ	OCR4A3	= 3	; Timer/Counter4 Output Compare Register Low Byte Bit 3
                                 .equ	OCR4A4	= 4	; Timer/Counter4 Output Compare Register Bit 4
                                 .equ	OCR4A5	= 5	; Timer/Counter4 Output Compare Register Bit 5
                                 .equ	OCR4A6	= 6	; Timer/Counter4 Output Compare Register Bit 6
                                 .equ	OCR4A7	= 7	; Timer/Counter4 Output Compare Register Bit 7
                                 
                                 ; TC4H - Timer/Counter4
                                 .equ	TC48	= 0	; Timer/Counter4 bit 8
                                 .equ	TC49	= 1	; Timer/Counter4 bit 9
                                 .equ	TC410	= 2	; Timer/Counter4 bit 10
                                 
                                 ; TCNT4 - Timer/Counter4 Low Bytes
                                 .equ	TC40	= 0	; Timer/Counter4 bit 0
                                 .equ	TC41	= 1	; Timer/Counter4 bit 1
                                 .equ	TC42	= 2	; Timer/Counter4 bit 2
                                 .equ	TC43	= 3	; Timer/Counter4  bit 3
                                 .equ	TC44	= 4	; Timer/Counter4 bit 4
                                 .equ	TC45	= 5	; Timer/Counter4 bit 5
                                 .equ	TC46	= 6	; Timer/Counter4 bit 6
                                 .equ	TC47	= 7	; Timer/Counter4 bit 7
                                 
                                 ; TCCR4E - Timer/Counter 4 Control Register E
                                 .equ	OC4OE0	= 0	; Output Compare Override Enable bit
                                 .equ	OC4OE1	= 1	; Output Compare Override Enable bit
                                 .equ	OC4OE2	= 2	; Output Compare Override Enable bit
                                 .equ	OC4OE3	= 3	; Output Compare Override Enable bit
                                 .equ	OC4OE4	= 4	; Output Compare Override Enable bit
                                 .equ	OC4OE5	= 5	; Output Compare Override Enable bit
                                 .equ	ENHC4	= 6	; Enhanced Compare/PWM Mode
                                 .equ	TLOCK4	= 7	; Register Update Lock
                                 
                                 ; TCCR4D - Timer/Counter 4 Control Register D
                                 .equ	WGM40	= 0	; Waveform Generation Mode bits
                                 .equ	WGM41	= 1	; Waveform Generation Mode bits
                                 .equ	FPF4	= 2	; Fault Protection Interrupt Flag
                                 .equ	FPAC4	= 3	; Fault Protection Analog Comparator Enable
                                 .equ	FPES4	= 4	; Fault Protection Edge Select
                                 .equ	FPNC4	= 5	; Fault Protection Noise Canceler
                                 .equ	FPEN4	= 6	; Fault Protection Mode Enable
                                 .equ	FPIE4	= 7	; Fault Protection Interrupt Enable
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	PWM4D	= 0	; Pulse Width Modulator D Enable
                                 .equ	FOC4D	= 1	; Force Output Compare Match 4D
                                 .equ	COM4D0	= 2	; Comparator D Output Mode
                                 .equ	COM4D1	= 3	; Comparator D Output Mode
                                 .equ	COM4B0S	= 4	; Comparator B Output Mode
                                 .equ	COM4B1S	= 5	; Comparator B Output Mode
                                 .equ	COM4A0S	= 6	; Comparator A Output Mode
                                 .equ	COM4A1S	= 7	; Comparator A Output Mode
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Clock Select Bit 0
                                 .equ	CS41	= 1	; Clock Select Bit 1
                                 .equ	CS42	= 2	; Clock Select Bit 2
                                 .equ	CS43	= 3	; Clock Select Bit 3
                                 .equ	DTPS40	= 4	; Dead Time Prescaler Bit 0
                                 .equ	DTPS41	= 5	; Dead Time Prescaler Bit 1
                                 .equ	PSR4	= 6	; Prescaler Reset Timer/Counter 4
                                 .equ	PWM4X	= 7	; PWM Inversion Mode
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	PWM4B	= 0	; 
                                 .equ	PWM4A	= 1	; 
                                 .equ	FOC4B	= 2	; Force Output Compare Match 4B
                                 .equ	FOC4A	= 3	; Force Output Compare Match 4A
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE6	= 6	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE6	= 6	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 .equ	ADTS3	= 4	; ADC Auto Trigger Source 3
                                 .equ	MUX5	= 5	; Analog Channel and Gain Selection Bits
                                 .equ	ADHSM	= 7	; ADC High Speed Mode
                                 
                                 ; DIDR0 - Digital Input Disable Register 1
                                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC4D	= 4	; ADC4 Digital input Disable
                                 .equ	ADC5D	= 5	; ADC5 Digital input Disable
                                 .equ	ADC6D	= 6	; ADC6 Digital input Disable
                                 .equ	ADC7D	= 7	; ADC7 Digital input Disable
                                 
                                 ; DIDR2 - Digital Input Disable Register 1
                                 .equ	ADC8D	= 0	; ADC8 Digital input Disable
                                 .equ	ADC9D	= 1	; ADC9 Digital input Disable
                                 .equ	ADC10D	= 2	; ADC10 Digital input Disable
                                 .equ	ADC11D	= 3	; ADC11 Digital input Disable
                                 .equ	ADC12D	= 4	; ADC12 Digital input Disable
                                 .equ	ADC13D	= 5	; ADC13 Digital input Disable
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; RCCTRL - Oscillator Control Register
                                 .equ	RCFREQ	= 0	; 
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRUSB	= 7	; Power Reduction USB
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 ; CLKSTA - 
                                 .equ	EXTON	= 0	; 
                                 .equ	RCON	= 1	; 
                                 
                                 ; CLKSEL0 - 
                                 .equ	CLKS	= 0	; 
                                 .equ	EXTE	= 2	; 
                                 .equ	RCE	= 3	; 
                                 .equ	EXSUT0	= 4	; 
                                 .equ	EXSUT1	= 5	; 
                                 .equ	RCSUT0	= 6	; 
                                 .equ	RCSUT1	= 7	; 
                                 
                                 ; CLKSEL1 - 
                                 .equ	EXCKSEL0	= 0	; 
                                 .equ	EXCKSEL1	= 1	; 
                                 .equ	EXCKSEL2	= 2	; 
                                 .equ	EXCKSEL3	= 3	; 
                                 .equ	RCCKSEL0	= 4	; 
                                 .equ	RCCKSEL1	= 5	; 
                                 .equ	RCCKSEL2	= 6	; 
                                 .equ	RCCKSEL3	= 7	; 
                                 
                                 
                                 ; ***** PLL **************************
                                 ; PLLCSR - PLL Status and Control register
                                 .equ	PLOCK	= 0	; PLL Lock Status Bit
                                 .equ	PLLE	= 1	; PLL Enable Bit
                                 .equ	PINDIV	= 4	; PLL prescaler Bit 2
                                 
                                 ; PLLFRQ - PLL Frequency Control Register
                                 .equ	PDIV0	= 0	; 
                                 .equ	PDIV1	= 1	; 
                                 .equ	PDIV2	= 2	; 
                                 .equ	PDIV3	= 3	; 
                                 .equ	PLLTM0	= 4	; 
                                 .equ	PLLTM1	= 5	; 
                                 .equ	PLLUSB	= 6	; 
                                 .equ	PINMUX	= 7	; 
                                 
                                 
                                 ; ***** USB_DEVICE *******************
                                 ; USBCON - USB General Control Register
                                 .equ	VBUSTE	= 0	; 
                                 .equ	OTGPADE	= 4	; 
                                 .equ	FRZCLK	= 5	; 
                                 .equ	USBE	= 7	; 
                                 
                                 ; UDCON - 
                                 .equ	DETACH	= 0	; 
                                 .equ	RMWKUP	= 1	; 
                                 .equ	LSM	= 2	; USB low speed mode
                                 .equ	RSTCPU	= 3	; 
                                 
                                 ; UDINT - 
                                 .equ	SUSPI	= 0	; 
                                 .equ	SOFI	= 2	; 
                                 .equ	EORSTI	= 3	; 
                                 .equ	WAKEUPI	= 4	; 
                                 .equ	EORSMI	= 5	; 
                                 .equ	UPRSMI	= 6	; 
                                 
                                 ; UDIEN - 
                                 .equ	SUSPE	= 0	; 
                                 .equ	SOFE	= 2	; 
                                 .equ	EORSTE	= 3	; 
                                 .equ	WAKEUPE	= 4	; 
                                 .equ	EORSME	= 5	; 
                                 .equ	UPRSME	= 6	; 
                                 
                                 ; UDADDR - 
                                 .equ	UADD0	= 0	; 
                                 .equ	UADD1	= 1	; 
                                 .equ	UADD2	= 2	; 
                                 .equ	UADD3	= 3	; 
                                 .equ	UADD4	= 4	; 
                                 .equ	UADD5	= 5	; 
                                 .equ	UADD6	= 6	; 
                                 .equ	ADDEN	= 7	; 
                                 
                                 ; UDFNUML - 
                                 .equ	FNUM0	= 0	; 
                                 .equ	FNUM1	= 1	; 
                                 .equ	FNUM2	= 2	; 
                                 .equ	FNUM3	= 3	; 
                                 .equ	FNUM4	= 4	; 
                                 .equ	FNUM5	= 5	; 
                                 .equ	FNUM6	= 6	; 
                                 .equ	FNUM7	= 7	; 
                                 
                                 ; UDFNUMH - 
                                 .equ	FNUM8	= 0	; 
                                 .equ	FNUM9	= 1	; 
                                 .equ	FNUM10	= 2	; 
                                 
                                 ; UDMFN - 
                                 .equ	FNCERR	= 4	; 
                                 
                                 ; UEINTX - 
                                 .equ	TXINI	= 0	; 
                                 .equ	STALLEDI	= 1	; 
                                 .equ	RXOUTI	= 2	; 
                                 .equ	RXSTPI	= 3	; 
                                 .equ	NAKOUTI	= 4	; 
                                 .equ	RWAL	= 5	; 
                                 .equ	NAKINI	= 6	; 
                                 .equ	FIFOCON	= 7	; 
                                 
                                 ; UENUM - 
                                 .equ	UENUM_0	= 0	; 
                                 .equ	UENUM_1	= 1	; 
                                 .equ	UENUM_2	= 2	; 
                                 
                                 ; UERST - 
                                 .equ	EPRST0	= 0	; 
                                 .equ	EPRST1	= 1	; 
                                 .equ	EPRST2	= 2	; 
                                 .equ	EPRST3	= 3	; 
                                 .equ	EPRST4	= 4	; 
                                 .equ	EPRST5	= 5	; 
                                 .equ	EPRST6	= 6	; 
                                 
                                 ; UECONX - 
                                 .equ	EPEN	= 0	; 
                                 .equ	RSTDT	= 3	; 
                                 .equ	STALLRQC	= 4	; 
                                 .equ	STALLRQ	= 5	; 
                                 
                                 ; UECFG0X - 
                                 .equ	EPDIR	= 0	; 
                                 .equ	EPTYPE0	= 6	; 
                                 .equ	EPTYPE1	= 7	; 
                                 
                                 ; UECFG1X - 
                                 .equ	ALLOC	= 1	; 
                                 .equ	EPBK0	= 2	; 
                                 .equ	EPBK1	= 3	; 
                                 .equ	EPSIZE0	= 4	; 
                                 .equ	EPSIZE1	= 5	; 
                                 .equ	EPSIZE2	= 6	; 
                                 
                                 ; UESTA0X - 
                                 .equ	NBUSYBK0	= 0	; 
                                 .equ	NBUSYBK1	= 1	; 
                                 .equ	DTSEQ0	= 2	; 
                                 .equ	DTSEQ1	= 3	; 
                                 .equ	UNDERFI	= 5	; 
                                 .equ	OVERFI	= 6	; 
                                 .equ	CFGOK	= 7	; 
                                 
                                 ; UESTA1X - 
                                 .equ	CURRBK0	= 0	; 
                                 .equ	CURRBK1	= 1	; 
                                 .equ	CTRLDIR	= 2	; 
                                 
                                 ; UEIENX - 
                                 .equ	TXINE	= 0	; 
                                 .equ	STALLEDE	= 1	; 
                                 .equ	RXOUTE	= 2	; 
                                 .equ	RXSTPE	= 3	; 
                                 .equ	NAKOUTE	= 4	; 
                                 .equ	NAKINE	= 6	; 
                                 .equ	FLERRE	= 7	; 
                                 
                                 ; UEDATX - 
                                 .equ	DAT0	= 0	; 
                                 .equ	DAT1	= 1	; 
                                 .equ	DAT2	= 2	; 
                                 .equ	DAT3	= 3	; 
                                 .equ	DAT4	= 4	; 
                                 .equ	DAT5	= 5	; 
                                 .equ	DAT6	= 6	; 
                                 .equ	DAT7	= 7	; 
                                 
                                 ; UEBCLX - 
                                 .equ	BYCT0	= 0	; 
                                 .equ	BYCT1	= 1	; 
                                 .equ	BYCT2	= 2	; 
                                 .equ	BYCT3	= 3	; 
                                 .equ	BYCT4	= 4	; 
                                 .equ	BYCT5	= 5	; 
                                 .equ	BYCT6	= 6	; 
                                 .equ	BYCT7	= 7	; 
                                 
                                 ; UEINT - 
                                 .equ	EPINT0	= 0	; 
                                 .equ	EPINT1	= 1	; 
                                 .equ	EPINT2	= 2	; 
                                 .equ	EPINT3	= 3	; 
                                 .equ	EPINT4	= 4	; 
                                 .equ	EPINT5	= 5	; 
                                 .equ	EPINT6	= 6	; 
                                 
                                 ; USBINT - 
                                 .equ	VBUSTI	= 0	; 
                                 
                                 ; USBSTA - 
                                 .equ	VBUS	= 0	; 
                                 .equ	SPEED	= 3	; 
                                 
                                 ; USBCON - USB General Control Register
                                 ;.equ	VBUSTE	= 0	; 
                                 ;.equ	OTGPADE	= 4	; 
                                 ;.equ	FRZCLK	= 5	; 
                                 ;.equ	USBE	= 7	; 
                                 
                                 ; UHWCON - 
                                 .equ	UVREGE	= 0	; 
                                 
                                 ; TWCR - Two-Wire Interface Control
                                 .equ		TWIE	= 0	;
                                 .equ 		TWEN	= 2	;
                                 .equ 		TWWC	= 3	;
                                 .equ 		TWSTO	= 4	;
                                 .equ 		TWSTA	= 5	;
                                 .equ 		TWEA	= 6	;
                                 .equ 		TWINT	= 7	;
                                 
                                 ; TWSR - Two-Wire Status
                                 .equ 		TWPS0	= 0	;
                                 .equ 		TWPS1	= 1	;
                                 
                                 ; TWAR
                                 .equ 		TWGCE	= 0	;
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	HWBE	= 3	; Hardware Boot Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2560
                                 .equ	RAMEND	= 0x0aff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2560
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	Reserved1addr	= 0x000a	; Reserved1
                                 .equ	Reserved2addr	= 0x000c	; Reserved2
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	Reserved3addr	= 0x0010	; Reserved3
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	USB_GENaddr	= 0x0014	; USB General Interrupt Request
                                 .equ	USB_COMaddr	= 0x0016	; USB Endpoint/Pipe Interrupt Communication Request
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	Reserved4addr	= 0x001a	; Reserved4
                                 .equ	Reserved5addr	= 0x001c	; Reserved5
                                 .equ	Reserved6addr	= 0x001e	; Reserved6
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC1addr	= 0x0032	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x0034	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x0036	; USART1, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	TWIaddr	= 0x0048	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x004a	; Store Program Memory Read
                                 .equ	OC4Aaddr	= 0x004c	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x004e	; Timer/Counter4 Compare Match B
                                 .equ	OC4Daddr	= 0x0050	; Timer/Counter4 Compare Match D
                                 .equ	OVF4addr	= 0x0052	; Timer/Counter4 Overflow
                                 .equ	TIMER4_FPFaddr	= 0x0054	; Timer/Counter4 Fault Protection Interrupt
                                 
                                 .equ	INT_VECTORS_SIZE	= 86	; size in words
                                 
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;*
                                 ;*   Author: Kenneth Tang
                                 ;*           Travis Fredrickson
                                 ;*     Date: 11/19/2022
                                 ;*
                                 ;***********************************************************
                                 
                                 .include "m32U4def.inc"         ; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*  Internal Register Definitions and Constants
                                 ;***********************************************************
                                 .def    mpr = r16               ; Multi-Purpose Register
                                 .def    waitcnt = r17           ; Wait Loop Counter
                                 .def    ilcnt = r18
                                 .def    olcnt = r19
                                 
                                 .equ    WTime = 15              ; Time to wait in wait loop
                                 
                                 .equ    SIGNAL_READY        = 0b1111_1111   ; Signal for ready to start game
                                 .equ    SIGNAL_NOT_READY    = 0b0000_0000   ; Signal for not ready to start game
                                 .equ    SIGNAL_ROCK         = 0b0000_0001   ; Signal for Rock
                                 .equ    SIGNAL_PAPER        = 0b0000_0010   ; Signal for Paper
                                 .equ    SIGNAL_SCISSORS     = 0b0000_0011   ; Signal for Scissors
                                 
                                 ;***********************************************************
                                 ;*  Start of Code Segment
                                 ;***********************************************************
                                 .cseg                           ; Beginning of code segment
                                 
                                 ;***********************************************************
                                 ;*  Interrupt Vectors
                                 ;***********************************************************
                                 .org    $0000                   ; Beginning of IVs
000000 c055                              rjmp INIT               ; Reset interrupt
                                 
                                 
                                 .org    $0002                   ; INT0  Cycle through selection
000002 d222                              rcall CYCLE_HAND
000003 9518                              reti
                                 
                                 .org    $0004                   ; INT1 Send Start Msg
000004 d12f                              rcall NEXT_GAME_STAGE
000005 9518                              reti
                                 
                                 .org    $0028                   ; Timer/Counter 1 Overflow
000028 d226                              rcall TIMER
000029 9518                              reti
                                 
                                 .org    $0032                   ; USART1 Rx Complete
000032 d0a0                              rcall MESSAGE_RECEIVE
000033 9518                              reti
                                 
                                 .org    $0034                   ; USART Data Register Empty
000034 9518                              reti
                                 
                                 .org    $0036                   ; USART1 Tx Complete
000036 d0ae                              rcall READY_CHECK
000037 9518                              reti
                                 
                                 .org    $0056                   ; End of Interrupt Vectors
                                 
                                 ;***********************************************************
                                 ;*  Program Initialization
                                 ;***********************************************************
                                 INIT:
                                     ; Initialize the Stack Pointer
000056 e00a                          ldi     mpr, high(RAMEND)
000057 bf0e                          out     SPH, mpr
000058 ef0f                          ldi     mpr, low(RAMEND)
000059 bf0d                          out     SPL, mpr
                                 
                                     ; I/O Ports
00005a e008                          ldi     mpr, (1<<PD3 | 0b0000_0000) ; Set Port D pin 3 (TXD1) for output
00005b b90a                          out     DDRD, mpr                   ; Set Port D pin 2 (RXD1) for input
00005c ef0f                          ldi     mpr, $FF                    ; Enable pull up resistors
00005d b90b                          out     PORTD, mpr
                                 
                                     ; Configure PORTB for output
00005e ef0f                          ldi     mpr, $FF
00005f b904                          out     DDRB, mpr
000060 e000                          ldi     mpr, $00
000061 b905                          out     PORTB, mpr
                                 
                                     ; USART1 Config
                                     ; Set double data rate
000062 e002                          ldi     mpr, (1<<U2X1)
000063 9300 00c8                     sts     UCSR1A, mpr
                                     ; Set recieve & transmit complete interrupts, transmitter & reciever enable, 8 data bits frame formate
000065 ed08                          ldi     mpr, (1<<RXCIE1 | 1<<TXCIE1 | 0<<UDRIE1 | 1<<RXEN1 | 1<<TXEN1 | 0<<UCSZ12)
000066 9300 00c9                     sts     UCSR1B, mpr
                                     ; Set frame formate: 8 data bits, 2 stop bits, asnych, no parity
000068 e00e                          ldi     mpr, (0<<UMSEL11 | 0<<UMSEL10 | 0<<UPM11 | 0<<UPM10 | 1<<USBS1 | 1<<UCSZ11 | 1<<UCSZ10 | 0<<UCPOL1)
000069 9300 00ca                     sts     UCSR1C, mpr
                                     ; Baud to 2400 @ double data rate
00006b e001                          ldi     mpr, high(416)
00006c 9300 00cd                     sts     UBRR1H, mpr
00006e ea00                          ldi     mpr, low(416)
00006f 9300 00cc                     sts     UBRR1L, mpr
                                     
                                     ; Timer/Counter 1
                                     ; Setup for normal mode WGM 0000
                                     ; COM disconnected 00
                                     ; Use OCR1A for top value
                                     ; CS TBD, using 100
000071 e000                          ldi     mpr, (0<<COM1A1 | 0<<COM1A0 | 0<<COM1B1 | 0<<COM1B0 | 0<<WGM11 | 0<<WGM10)
000072 9300 0080                     sts     TCCR1A, mpr
000074 e004                          ldi     mpr, (0<<WGM13 | 0<<WGM12 | 1<<CS12 | 0<<CS11 | 0<<CS10)
000075 9300 0081                     sts     TCCR1B, mpr
                                     
                                     ; LED Initialization
000077 940e 02fc                     call    LCDInit                         ; Initialize LCD
000079 940e 031e                     call    LCDBacklightOn
00007b e0f5                          ldi     ZH, high(STRING_IDLE<<1)        ; Point Z to the welcome string
00007c e4e8                          ldi     ZL, low(STRING_IDLE<<1)
00007d 940e 009d                     call    LCD_ALL                         ; Print welcome message
                                 
                                     ; Data Memory Variables
                                         ; TIMER_STAGE
00007f e004                          ldi     mpr, 4
000080 e0b2                          ldi     XH, high(TIMER_STAGE)
000081 e0a0                          ldi     XL, low(TIMER_STAGE)
000082 930c                          st      X, mpr
                                 
                                         ; GAME_STAGE
000083 e000                          ldi     mpr, 0
000084 e0b2                          ldi     XH, high(GAME_STAGE)
000085 e0a1                          ldi     XL, low(GAME_STAGE)
000086 930c                          st      X, mpr
                                 
                                         ; HANDs
000087 e001                          ldi     mpr, SIGNAL_ROCK            ; Default hand
000088 e0b2                          ldi     XH, high(HAND_OPNT)
000089 e0a2                          ldi     XL, low(HAND_OPNT)
00008a 930c                          st      X, mpr
00008b e0b2                          ldi     XH, high(HAND_USER)
00008c e0a3                          ldi     XL, low(HAND_USER)
00008d 930c                          st      X, mpr
                                 
                                         ; READY Flags
00008e e000                          ldi     mpr, SIGNAL_NOT_READY
00008f e0b2                          ldi     XH, high(READY_OPNT)
000090 e0a4                          ldi     XL, low(READY_OPNT)
000091 930c                          st      X, mpr
000092 e0b2                          ldi     XH, high(READY_USER)
000093 e0a5                          ldi     XL, low(READY_USER)
000094 930c                          st      X, mpr
                                 
                                    
                                 
                                     ; External Interrupts
                                     ; Initialize external interrupts
000095 e00a                          ldi     mpr, 0b0000_1010            ; Set INT1, INT0 to trigger on 
000096 9300 0069                     sts     EICRA, mpr                  ; falling edge
                                 
                                     ; Configure the External Interrupt Mask
000098 e000                          ldi     mpr, (0<<INT1 | 0<<INT0)    ; Disable INT1 and INT0 for now
000099 bb0d                          out     EIMSK, mpr
                                 
00009a d099                          rcall   NEXT_GAME_STAGE
                                 
                                 
                                     ; Enable global interrupts
00009b 9478                          sei
                                 
                                 
                                 ;***********************************************************
                                 ;*  Main Program
                                 ;***********************************************************
                                 MAIN:
                                 
00009c cfff                              rjmp    MAIN
                                 
                                 
                                 ;***********************************************************
                                 ;*  Functions and Subroutines
                                 ;***********************************************************
                                 
                                 ; Printing functions ----------------
                                 LCD_ALL:
                                     ;-----------------------------------------------------------
                                     ; Func: LCD All
                                     ; Desc: Prints a string to the entire LCD
                                     ;       Assumes Z already points to string.
                                     ;-----------------------------------------------------------
                                     ; Save variables
00009d 930f                          push    mpr
00009e 932f                          push    ilcnt
00009f 93bf                          push    XH
0000a0 93af                          push    XL
                                 
                                     ; Set parameters
0000a1 e0b1                          ldi     XH, $01                     ; Point X to LCD top line
0000a2 e0a0                          ldi     XL, $00                     ; ^
0000a3 e220                          ldi     ilcnt, 32                   ; Loop 32 times for 32 characters
                                 
                                  LCD_ALL_LOOP:
                                     ; Load in characters
0000a4 9105                          lpm     mpr, Z+
0000a5 930d                          st      X+, mpr
0000a6 952a                          dec     ilcnt
0000a7 f7e1                          brne    LCD_ALL_LOOP
                                 
                                     ; Write to LCD
0000a8 940e 0322                     call    LCDWrite
                                 
                                     ; Restore variables
0000aa 91af                          pop     XL
0000ab 91bf                          pop     XH
0000ac 912f                          pop     ilcnt
0000ad 910f                          pop     mpr
                                 
                                     ; Return from function
0000ae 9508                          ret
                                 
                                 LCD_TOP:
                                     ;-----------------------------------------------------------
                                     ; Func: LCD Top
                                     ; Desc: Prints a string to the top row of the LCD
                                     ;       Assumes Z already points to string.
                                     ;-----------------------------------------------------------
                                     ; Save variables
0000af 930f                          push    mpr
0000b0 932f                          push    ilcnt
0000b1 93bf                          push    XH
0000b2 93af                          push    XL
                                 
                                     ; Set parameters
0000b3 e0b1                          ldi     XH, $01                     ; Point X to LCD top line
0000b4 e0a0                          ldi     XL, $00                     ; ^
0000b5 e120                          ldi     ilcnt, 16                   ; Loop 16 times for 16 characters
                                 
                                  LCD_TOP_LOOP:
                                     ; Load in characters
0000b6 9105                          lpm     mpr, Z+
0000b7 930d                          st      X+, mpr
0000b8 952a                          dec     ilcnt
0000b9 f7e1                          brne    LCD_TOP_LOOP
                                 
                                     ; Write to LCD
0000ba 940e 0322                     call    LCDWrite
                                 
                                     ; Restore variables
0000bc 91af                          pop     XL
0000bd 91bf                          pop     XH
0000be 912f                          pop     ilcnt
0000bf 910f                          pop     mpr
                                 
                                     ; Return from function
0000c0 9508                          ret
                                     
                                 LCD_BOTTOM:
                                     ;-----------------------------------------------------------
                                     ; Func: LCD Bottom
                                     ; Desc: Prints a string to the bottom row of the LCD
                                     ;       Assumes Z already points to string.
                                     ;-----------------------------------------------------------
                                     ; Save variables
0000c1 930f                          push    mpr
0000c2 932f                          push    ilcnt
0000c3 93bf                          push    XH
0000c4 93af                          push    XL
                                 
                                     ; Set parameters
0000c5 e0b1                          ldi     XH, $01                     ; Point X to LCD bottom line
0000c6 e1a0                          ldi     XL, $10                     ; ^
0000c7 e120                          ldi     ilcnt, 16                   ; Loop 16 times for 16 characters
                                 
                                  LCD_BOTTOM_LOOP:
                                     ; Load in characters
0000c8 9105                          lpm     mpr, Z+
0000c9 930d                          st      X+, mpr
0000ca 952a                          dec     ilcnt
0000cb f7e1                          brne    LCD_BOTTOM_LOOP
                                 
                                     ; Write to LCD
0000cc 940e 0322                     call    LCDWrite
                                 
                                     ; Restore variables
0000ce 91af                          pop     XL
0000cf 91bf                          pop     XH
0000d0 912f                          pop     ilcnt
0000d1 910f                          pop     mpr
                                 
                                     ; Return from function
0000d2 9508                          ret
                                 
                                 ; USART -----------------------------
                                 MESSAGE_RECEIVE:
                                     ;----------------------------------------------------------------
                                     ; Sub:  Message Receive
                                     ; Desc: After receiving data, this function decides what to do with it
                                     ;       It performs checks on it to see what was sent in then branches
                                     ;       to the appropriate function.
                                     ;----------------------------------------------------------------
0000d3 930f                          push mpr
0000d4 93ff                          push ZH
0000d5 93ef                          push ZL
0000d6 94f8                          cli                             ; Turn interrupts off
                                     
                                     ;--------- Read message in UDR1 -----------;
0000d7 9100 00ce                     lds     mpr, UDR1               ; Read the incoming data
0000d9 3f0f                          cpi     mpr, SIGNAL_READY       
0000da f019                          breq    MR_READY                ; If its the ready signal
0000db 940e 01f8                     call    STORE_HAND              ; Else it must be a hand signal
0000dd c002                          rjmp    MR_END
                                 
                                 
                                  MR_READY:
0000de 940e 0117                     call    RECEIVE_START           ; Set OPNT ready flag and advance game stage
                                  
                                  MR_END:
0000e0 9478                          sei                             ; Turn interrupts back on
0000e1 91ef                          pop ZL
0000e2 91ff                          pop ZH
0000e3 910f                          pop mpr
0000e4 9508                          ret
                                 
                                 READY_CHECK:
                                     ;----------------------------------------------------------------
                                     ; Sub:  Ready Check
                                     ; Desc: Does a status check after a message has been transmitter on USART1
                                     ;----------------------------------------------------------------
0000e5 930f                          push mpr
0000e6 932f                          push ilcnt
0000e7 93ff                          push ZH
0000e8 93ef                          push ZL
0000e9 93bf                          push XH
0000ea 93af                          push XL
                                 
                                     ;--------- Check to see if we should start the game ----------------;
0000eb e0f2                          ldi     ZH, high(READY_USER)            ; Load both ready flags
0000ec e0e5                          ldi     ZL, low(READY_USER)
0000ed 8100                          ld      mpr, Z
0000ee e0b2                          ldi     XH, high(READY_OPNT)
0000ef e0a4                          ldi     XL, low(READY_OPNT)
0000f0 912c                          ld      ilcnt, X
0000f1 3f0f                          cpi     mpr, SIGNAL_READY
0000f2 f431                          brne    TC_END                          ; If they aren't equal to ready jump to end
0000f3 3f2f                          cpi     ilcnt, SIGNAL_READY
0000f4 f421                          brne    TC_END                          ; If they aren't equal to ready jump to end
                                 
                                     ;--------- If both ready ---------------;
0000f5 e000                          ldi     mpr, SIGNAL_NOT_READY           ; Change ready flags
0000f6 8300                          st      Z, mpr
0000f7 930c                          st      X, mpr
0000f8 d03b                          rcall   NEXT_GAME_STAGE                 ; If both flags are ready, advance game
                                 
                                  TC_END:
                                     ; Other checks
0000f9 91af                          pop XL
0000fa 91bf                          pop XH
0000fb 91ef                          pop ZL
0000fc 91ff                          pop ZH
0000fd 912f                          pop ilcnt
0000fe 910f                          pop mpr
0000ff 9508                          ret
                                 
                                 SEND_READY:
                                     ;----------------------------------------------------------------
                                     ; Sub:  Send ready
                                     ; Desc: Sends the ready message via USART1 and sets he user's ready flag
                                     ;       to be SIGNAL_READY
                                     ;----------------------------------------------------------------
                                     ; Here we need to send a message via USART
000100 930f                          push mpr
000101 931f                          push waitcnt
000102 93ff                          push ZH
000103 93ef                          push ZL
                                 
                                 
000104 e0f2                          ldi     ZH, high(READY_USER)        ; Load the ready flag
000105 e0e5                          ldi     ZL, low(READY_USER)
000106 ef0f                          ldi     mpr, SIGNAL_READY
000107 8300                          st      Z, mpr                      ; Store a 1 to the ready flag
                                 
                                     ;----- Transmit via USART ----------;
                                  Ready_Transmit:
000108 9100 00c8                     lds     mpr, UCSR1A                 ; Load in USART status register
00010a ff05                          sbrs    mpr, UDRE1                  ; Check the UDRE1 flag
00010b cffc                          rjmp    Ready_Transmit              ; Loop back until data register is empty
                                 
00010c ef0f                          ldi     mpr, SIGNAL_READY           ; Send the start message to the other board
00010d 9300 00ce                     sts     UDR1, mpr
                                 
                                     ;----- Clear the queue -------------;
00010f d184                          rcall   BUSY_WAIT                   ; Wait to clear queue
000110 e003                          ldi     mpr, 0b0000_0011            ; Clear interrupts
000111 bb0c                          out     EIFR, mpr
                                 
000112 91ef                          pop ZL
000113 91ff                          pop ZH
000114 911f                          pop waitcnt
000115 910f                          pop mpr
000116 9508                          ret
                                 
                                 RECEIVE_START:
                                     ;----------------------------------------------------------------
                                     ; Sub:  Receive start
                                     ; Desc: Called when USART1 receive interrupt determines it has
                                     ;       received the start message. Changes the opponents ready 
                                     ;       flag to be SIGNAL_READY and calls READY_CHECK to see if 
                                     ;       the game stage should advance (ie start the game)
                                     ;----------------------------------------------------------------
000117 930f                          push mpr
000118 93ff                          push ZH
000119 93ef                          push ZL
                                 
00011a ef0f                          ldi     mpr, SIGNAL_READY       ; Change opponents ready flag to 1
00011b e0f2                          ldi     ZH, high(READY_OPNT)
00011c e0e4                          ldi     ZL, low(READY_OPNT)
00011d 8300                          st      Z, mpr
00011e 940e 00e5                     call    READY_CHECK             ; Check to see if we should start
                                 
000120 91ef                          pop ZL
000121 91ff                          pop ZH
000122 910f                          pop mpr
000123 9508                          ret
                                 
                                 SEND_HAND:
                                     ;----------------------------------------------------------------
                                     ; Sub:  Send hand
                                     ; Desc: Sends the user's current hand via USART1.
                                     ;----------------------------------------------------------------
                                 
000124 930f                          push mpr
000125 93ff                          push ZH
000126 93ef                          push ZL
                                 
                                  Hand_Transmit:
                                     ; See if the USART data register is empty
000127 9100 00c8                     lds     mpr, UCSR1A             ; UDRE1 will be 1 when buffer is empty
000129 ff05                          sbrs    mpr, UDRE1              ; Test only the 5th bit
00012a cffc                          rjmp    Hand_Transmit
                                 
00012b e0f2                          ldi     ZH, high(HAND_USER)     ; Load the user's hand
00012c e0e3                          ldi     ZL, low(HAND_USER)      
00012d 8100                          ld      mpr, Z 
00012e 9300 00ce                     sts     UDR1, mpr               ; Send user's hand via USART1
                                 
000130 91ef                          pop ZL
000131 91ff                          pop ZH
000132 910f                          pop mpr
000133 9508                          ret
                                 
                                 ; Core game -------------------------
                                 NEXT_GAME_STAGE:
                                     ;-----------------------------------------------------------
                                     ; Func: Next game stage
                                     ; Desc: This is essentially the core function of the game.
                                     ;       Game stages change as follows:
                                     ;           0 -> 1      0 = IDLE
                                     ;           1 -> 2      1 = READY UP
                                     ;           2 -> 3      2 = SELECT HAND
                                     ;           3 -> 4      3 = SEND & RECEIVE HANDS
                                     ;           4 -> 5      4 = REVEAL HANDS
                                     ;           5 -> 0      5 = RESULT
                                     ;-----------------------------------------------------------
                                     ; Save variables
000134 930f                          push    mpr
000135 93bf                          push    XH
000136 93af                          push    XL
                                 
                                     ; Branch based on current Game Stage
000137 e0b2                          ldi     XH, high(GAME_STAGE)
000138 e0a1                          ldi     XL, low(GAME_STAGE)
000139 910c                          ld      mpr, X
                                 
00013a 3000                          cpi     mpr, 0
00013b f059                          breq    NEXT_GAME_STAGE_0
00013c 3001                          cpi     mpr, 1
00013d f079                          breq    NEXT_GAME_STAGE_1
00013e 3002                          cpi     mpr, 2
00013f f099                          breq    NEXT_GAME_STAGE_2
000140 3003                          cpi     mpr, 3
000141 f0b9                          breq    NEXT_GAME_STAGE_3
000142 3004                          cpi     mpr, 4
000143 f0d9                          breq    NEXT_GAME_STAGE_4
000144 3005                          cpi     mpr, 5
000145 f0e9                          breq    NEXT_GAME_STAGE_5
                                 
                                     ; If no compare match, branch to end
000146 c020                          rjmp    NEXT_GAME_STAGE_END
                                 
                                  NEXT_GAME_STAGE_0:                     ; IDLE
                                     ; Print the welcome message
                                     ; Enable PD7
000147 d026                          rcall   GAME_STAGE_0
000148 e001                          ldi     mpr, 1                      ; Update GAME_STAGE
000149 930c                          st      X, mpr
00014a e002                          ldi     mpr, (1<<INT1)              ; Enable INT1 (PD7) so it can start the game again
00014b bb0d                          out     EIMSK, mpr
00014c c01a                          rjmp    NEXT_GAME_STAGE_END         ; Jump to end
                                 
                                  NEXT_GAME_STAGE_1:                     ; READY UP
                                     ; Disable PD7 
                                     ; Print ready message
                                     ; Send ready message
00014d e000                          ldi     mpr, (0<<INT1)              ; Disable INT1 (PD7) because it's only use was to start the game
00014e bb0d                          out     EIMSK, mpr
00014f d026                          rcall   GAME_STAGE_1                ; Do stuff for this stage
000150 e002                          ldi     mpr, 2                      ; Update GAME_STAGE
000151 930c                          st      X, mpr
000152 c014                          rjmp    NEXT_GAME_STAGE_END         ; Jump to end
                                     
                                  NEXT_GAME_STAGE_2:                     ; CHOOSE HAND
                                     ; Display user hand on bottom row
                                     ; Starts the timer
                                     ; Enables PD4
000153 d02b                          rcall   GAME_STAGE_2
000154 e003                          ldi     mpr, 3                      ; Update GAME_STAGE
000155 930c                          st      X, mpr
000156 e001                          ldi     mpr, (1<<INT0)              ; Enable INT0 so hand can be changed
000157 bb0d                          out     EIMSK, mpr
000158 c00e                          rjmp    NEXT_GAME_STAGE_END         ; Jump to end
                                 
                                  NEXT_GAME_STAGE_3:
                                     ; Disable PD4
                                     ; Send user's hand
                                     ; wait for recieve
000159 e000                          ldi     mpr, (0<<INT0)              ; Disable INT0 so hand cannot be changed
00015a bb0d                          out     EIMSK, mpr
00015b 940e 0124                     call    SEND_HAND                   ; Send user hand to USART
                                                                         ; Recieve hand USART
                                                                         ; Taken care of by receive complete interrupt
00015d e004                          ldi     mpr, 4                      ; Update GAME_STAGE
00015e 930c                          st      X, mpr
                                 
                                  NEXT_GAME_STAGE_4:                     ; REVEAL HANDS
                                     ; Start 6 second timer
                                     ; Display opnt hand on LCD top row
00015f d04a                          rcall   GAME_STAGE_4                ; Do stuff for this stage
000160 e005                          ldi     mpr, 5                      ; Update GAME_STAGE
000161 930c                          st      X, mpr                      ; ^
000162 c004                          rjmp    NEXT_GAME_STAGE_END         ; Jump to end
                                 
                                  NEXT_GAME_STAGE_5:                     ; RESULT
                                     ; Start 6 second timer
                                     ; Determine the winner
                                     ; Print win/loss/tie msg on the LCD
000163 d068                          rcall   GAME_STAGE_5                ; Do stuff for this stage
000164 e000                          ldi     mpr, 0                      ; Update GAME_STAGE, so it wraps around and next time it begins at the start
000165 930c                          st      X, mpr                      ; ^
000166 c000                          rjmp    NEXT_GAME_STAGE_END         ; Jump to end
                                 
                                  NEXT_GAME_STAGE_END:
                                     ; Clear interrupt queue
000167 d12c                          rcall   BUSY_WAIT
000168 ef0f                          ldi     mpr, 0b1111_1111
000169 bb0c                          out     EIFR, mpr
                                 
                                     ; Restore variables
00016a 91af                          pop     XL
00016b 91bf                          pop     XH
00016c 910f                          pop     mpr
                                 
                                     ; Return from function
00016d 9508                          ret
                                 
                                 GAME_STAGE_0:
                                     ;-----------------------------------------------------------
                                     ; Func: Game stage 0
                                     ; Desc: Prints the welcome message to the LCD
                                     ;-----------------------------------------------------------
                                     ; Save variables
00016e 93ff                          push    ZH
00016f 93ef                          push    ZL
                                 
                                     ; Print to LCD
000170 e0f5                          ldi     ZH, high(STRING_IDLE<<1)
000171 e4e8                          ldi     ZL, low(STRING_IDLE<<1)
000172 df2a                          rcall   LCD_ALL
                                 
                                     ; Restore variables
000173 91ef                          pop     ZL
000174 91ff                          pop     ZH
                                 
                                     ; Return from function
000175 9508                          ret
                                 
                                 GAME_STAGE_1:
                                     ;-----------------------------------------------------------
                                     ; Func: Game stage 1
                                     ; Desc: Prints the ready message to the LCD and sends the ready
                                     ;       message via USART1
                                     ;-----------------------------------------------------------
                                     ; Save variables
000176 93ff                          push    ZH
000177 93ef                          push    ZL
                                 
                                     ; Print to LCD
000178 e0f5                          ldi     ZH, high(STRING_READY_UP<<1)
000179 e6e8                          ldi     ZL, low(STRING_READY_UP<<1)
00017a df22                          rcall   LCD_ALL
                                 
                                     ; Send ready message to other board
00017b df84                          rcall   SEND_READY
                                 
                                     ; Restore variables
00017c 91ef                          pop     ZL
00017d 91ff                          pop     ZH
                                 
                                     ; Return from function
00017e 9508                          ret
                                 
                                 GAME_STAGE_2:
                                     ;-----------------------------------------------------------
                                     ; Func: Game stage 2
                                     ; Desc: Starts the 6 second timer and displays the default 
                                     ;       choice of what the user's hand it to the bottom row
                                     ;       of the LCD
                                     ;-----------------------------------------------------------
                                     ; Save variables
00017f 930f                          push    mpr
000180 93bf                          push    XH
000181 93af                          push    XL
000182 93ff                          push    ZH
000183 93ef                          push    ZL
                                 
                                     ; Start 6 second timer
000184 d0ca                          rcall   TIMER
                                 
                                     ; Print to LCD
000185 e0f5                          ldi     ZH, high(STRING_CHOOSE_HAND<<1)
000186 e8e8                          ldi     ZL, low(STRING_CHOOSE_HAND<<1)
000187 df27                          rcall   LCD_TOP
                                 
                                     ; Load in HAND_USER
000188 e0b2                          ldi     XH, high(HAND_USER)
000189 e0a3                          ldi     XL, low(HAND_USER)
00018a 910c                          ld      mpr, X
                                 
                                     ; Display default hand
00018b 3001                          cpi     mpr, SIGNAL_ROCK                ; These compares are to print
00018c f029                          breq    GAME_STAGE_2_ROCK               ; the correct screen to the LCD
00018d 3002                          cpi     mpr, SIGNAL_PAPER
00018e f049                          breq    GAME_STAGE_2_PAPER
00018f 3003                          cpi     mpr, SIGNAL_SCISSORS
000190 f069                          breq    GAME_STAGE_2_SCISSORS
                                 
                                     ; If no compare match, jump to end
000191 c012                          rjmp    GAME_STAGE_2_END
                                 
                                  GAME_STAGE_2_ROCK:                         ; Change to ROCK
                                     ; Change Data Memory variable HAND_USER
000192 e001                          ldi     mpr, SIGNAL_ROCK
000193 930c                          st      X, mpr
                                 
                                     ; Print to LCD
000194 e0f5                          ldi     ZH, high(STRING_ROCK<<1)        ; Point Z to string
000195 ece8                          ldi     ZL, low(STRING_ROCK<<1)         ; ^
000196 df2a                          rcall   LCD_BOTTOM
                                 
                                     ; Jump to end
000197 c00c                          rjmp    GAME_STAGE_2_END
                                 
                                  GAME_STAGE_2_PAPER:                            ; Change to PAPER
                                     ; Change Data Memory variable HAND_USER
000198 e002                          ldi     mpr, SIGNAL_PAPER
000199 930c                          st      X, mpr
                                 
                                     ; Print to LCD
00019a e0f5                          ldi     ZH, high(STRING_PAPER<<1)       ; Point Z to string
00019b ede8                          ldi     ZL, low(STRING_PAPER<<1)        ; ^
00019c df24                          rcall   LCD_BOTTOM
                                 
                                     ; Jump to end
00019d c006                          rjmp    GAME_STAGE_2_END
                                 
                                  GAME_STAGE_2_SCISSORS:                     ; Change to SCISSORS
                                     ; Change Data Memory variable HAND_USER
00019e e003                          ldi     mpr, SIGNAL_SCISSORS
00019f 930c                          st      X, mpr
                                 
                                     ; Print to LCD
0001a0 e0f5                          ldi     ZH, high(STRING_SCISSORS<<1)    ; Point Z to string
0001a1 eee8                          ldi     ZL, low(STRING_SCISSORS<<1)     ; ^
0001a2 df1e                          rcall   LCD_BOTTOM
                                 
                                     ; Jump to end
0001a3 c000                          rjmp    GAME_STAGE_2_END
                                 
                                  GAME_STAGE_2_END:
                                     ; Restore variables
0001a4 91ef                          pop     ZL
0001a5 91ff                          pop     ZH
0001a6 91af                          pop     XL
0001a7 91bf                          pop     XH
0001a8 910f                          pop     mpr
                                 
                                     ; Return from function
0001a9 9508                          ret
                                 
                                 GAME_STAGE_4:
                                     ;-----------------------------------------------------------
                                     ; Func: Game stage 4
                                     ; Desc: Starts the 6 second timer and displays the opponents hand
                                     ;       to the top row of the LCD
                                     ;-----------------------------------------------------------
                                     ; Save variables
0001aa 930f                          push    mpr
0001ab 93bf                          push    XH
0001ac 93af                          push    XL
0001ad 93ff                          push    ZH
0001ae 93ef                          push    ZL
                                 
                                     ; Start 6 second timer
0001af d09f                          rcall   TIMER
                                     
                                     ; Branch based on Opponent Hand
0001b0 e0b2                          ldi     XH, high(HAND_OPNT)
0001b1 e0a2                          ldi     XL, low(HAND_OPNT)
0001b2 910c                          ld      mpr, X
                                     
0001b3 3001                          cpi     mpr, 1
0001b4 f029                          breq    GAME_STAGE_4_ROCK
0001b5 3002                          cpi     mpr, 2
0001b6 f039                          breq    GAME_STAGE_4_PAPER
0001b7 3003                          cpi     mpr, 3
0001b8 f049                          breq    GAME_STAGE_4_SCISSORS
                                 
                                     ; If no compare match, branch to end
0001b9 c00c                          rjmp    GAME_STAGE_4_END
                                 
                                  GAME_STAGE_4_ROCK:
                                     ; Print to LCD
0001ba e0f5                          ldi     ZH, high(STRING_ROCK<<1)
0001bb ece8                          ldi     ZL, low(STRING_ROCK<<1)
0001bc def2                          rcall   LCD_TOP
                                 
                                     ; Jump to end
0001bd c008                          rjmp    GAME_STAGE_4_END
                                 
                                  GAME_STAGE_4_PAPER:
                                     ; Print to LCD
0001be e0f5                          ldi     ZH, high(STRING_PAPER<<1)
0001bf ede8                          ldi     ZL, low(STRING_PAPER<<1)
0001c0 deee                          rcall   LCD_TOP
                                 
                                     ; Jump to end
0001c1 c004                          rjmp    GAME_STAGE_4_END
                                 
                                  GAME_STAGE_4_SCISSORS:
                                     ; Print to LCD
0001c2 e0f5                          ldi     ZH, high(STRING_SCISSORS<<1)
0001c3 eee8                          ldi     ZL, low(STRING_SCISSORS<<1)
0001c4 deea                          rcall   LCD_TOP
                                 
                                     ; Jump to end
0001c5 c000                          rjmp    GAME_STAGE_4_END
                                 
                                  GAME_STAGE_4_END:
                                     ; Restore variables
0001c6 91ef                          pop     ZL
0001c7 91ff                          pop     ZH
0001c8 91af                          pop     XL
0001c9 91bf                          pop     XH
0001ca 910f                          pop     mpr
                                 
                                     ; Return from function
0001cb 9508                          ret
                                 
                                 GAME_STAGE_5:
                                     ;-----------------------------------------------------------
                                     ; Func: Game stage 5
                                     ; Desc: Starts the 6 second timer and determins the winner 
                                     ;       based on the user's hand and opponent's hand. Displays
                                     ;       the result on the top line of the LCD
                                     ;-----------------------------------------------------------
                                     ; Save variables
0001cc 930f                          push    mpr
0001cd 932f                          push    ilcnt
0001ce 93bf                          push    XH
0001cf 93af                          push    XL
0001d0 93ff                          push    ZH
0001d1 93ef                          push    ZL
                                 
                                     ; Start 6 second timer
0001d2 d07c                          rcall   TIMER
                                 
                                     ; Decide Won/Lost/Draw
                                     ; Decision is based on subtracting the opnt's hand from the user's hand
                                     ; Result = user - opnt
                                         ; Calculate result value
                                             ; Won   = -2, 1
                                             ; Lost  = -1, 2
                                             ; Draw  = 0
0001d3 e0b2                          ldi     XH, high(HAND_USER)
0001d4 e0a3                          ldi     XL, low(HAND_USER)
0001d5 910c                          ld      mpr, X
0001d6 e0b2                          ldi     XH, high(HAND_OPNT)
0001d7 e0a2                          ldi     XL, low(HAND_OPNT)
0001d8 912c                          ld      ilcnt, X
0001d9 1b02                          sub     mpr, ilcnt              ; Result value stored in mpr
                                 
                                     ; Branch based on result
0001da 3f0e                          cpi     mpr, -2
0001db f049                          breq    GAME_STAGE_5_WON
0001dc 3001                          cpi     mpr, 1
0001dd f039                          breq    GAME_STAGE_5_WON
0001de 3f0f                          cpi     mpr, -1
0001df f049                          breq    GAME_STAGE_5_LOST
0001e0 3002                          cpi     mpr, 2
0001e1 f039                          breq    GAME_STAGE_5_LOST
0001e2 3000                          cpi     mpr, 0
0001e3 f049                          breq    GAME_STAGE_5_DRAW
                                 
                                     ; If no compare match, jump to end
0001e4 c00c                          rjmp    GAME_STAGE_5_END
                                 
                                  GAME_STAGE_5_WON:
                                     ; Print to LCD
0001e5 e0f5                          ldi     ZH, high(STRING_WON<<1)
0001e6 e9e8                          ldi     ZL, low(STRING_WON<<1)
0001e7 dec7                          rcall   LCD_TOP
                                 
                                     ; Jump to end
0001e8 c008                          rjmp    GAME_STAGE_5_END
                                 
                                  GAME_STAGE_5_LOST:
                                     ; Print to LCD
0001e9 e0f5                          ldi     ZH, high(STRING_LOST<<1)
0001ea eae8                          ldi     ZL, low(STRING_LOST<<1)
0001eb dec3                          rcall   LCD_TOP
                                 
                                     ; Jump to end
0001ec c004                          rjmp    GAME_STAGE_5_END
                                 
                                  GAME_STAGE_5_DRAW:
                                     ; Print to LCD
0001ed e0f5                          ldi     ZH, high(STRING_DRAW<<1)
0001ee ebe8                          ldi     ZL, low(STRING_DRAW<<1)
0001ef debf                          rcall   LCD_TOP
                                 
                                     ; Jump to end
0001f0 c000                          rjmp    GAME_STAGE_5_END
                                 
                                  GAME_STAGE_5_END:
                                     ; Restore variables
0001f1 91ef                          pop     ZL
0001f2 91ff                          pop     ZH
0001f3 91af                          pop     XL
0001f4 91bf                          pop     XH
0001f5 912f                          pop     ilcnt
0001f6 910f                          pop     mpr
                                 
                                     ; Return from function
0001f7 9508                          ret
                                 
                                 STORE_HAND:
                                     ;-----------------------------------------------------------
                                     ; Func: Store hand
                                     ; Desc: Stores the incoming opponents hand to HAND_OPNT
                                     ;       Assumes that the mpr is holding the intended message
                                     ;       Should be called directly from MESSAGE_RECEIVE
                                     ;-----------------------------------------------------------
0001f8 930f                          push mpr
0001f9 93ff                          push ZH
0001fa 93ef                          push ZL
                                 
0001fb e0f2                          ldi     ZH, high(HAND_OPNT)     ; mpr currently holds OPNT hand
0001fc e0e2                          ldi     ZL, low(HAND_OPNT)
0001fd 8300                          st      Z, mpr                  ; Store the hand received
0001fe 940e 0204                     call    PRINT_HAND
                                 
000200 91ef                          pop ZL
000201 91ff                          pop ZH
000202 910f                          pop mpr
000203 9508                          ret 
                                 
                                 PRINT_HAND:
                                     ;-----------------------------------------------------------
                                     ; Func: Print hand
                                     ; Desc: Prints the opponent's hand on the top row of the LCD
                                     ;-----------------------------------------------------------
000204 930f                          push mpr
000205 93bf                          push XH
000206 93af                          push XL
000207 93ff                          push ZH
000208 93ef                          push ZL
                                 
                                     ; Branch based on Opponent Hand
000209 e0b2                          ldi     XH, high(HAND_OPNT)
00020a e0a2                          ldi     XL, low(HAND_OPNT)
00020b 910c                          ld      mpr, X
                                     
00020c 3001                          cpi     mpr, 1
00020d f029                          breq    PRINT_HAND_ROCK
00020e 3002                          cpi     mpr, 2
00020f f039                          breq    PRINT_HAND_PAPER
000210 3003                          cpi     mpr, 3
000211 f049                          breq    PRINT_HAND_SCISSORS
                                 
                                     ; If no compare match, branch to end
000212 c00c                          rjmp    PRINT_HAND_END
                                 
                                  PRINT_HAND_ROCK:
                                     ; Print to LCD
000213 e0f5                          ldi     ZH, high(STRING_ROCK<<1)
000214 ece8                          ldi     ZL, low(STRING_ROCK<<1)
000215 de99                          rcall   LCD_TOP
                                 
                                     ; Jump to end
000216 c008                          rjmp    PRINT_HAND_END
                                 
                                  PRINT_HAND_PAPER:
                                     ; Print to LCD
000217 e0f5                          ldi     ZH, high(STRING_PAPER<<1)
000218 ede8                          ldi     ZL, low(STRING_PAPER<<1)
000219 de95                          rcall   LCD_TOP
                                 
                                     ; Jump to end
00021a c004                          rjmp    PRINT_HAND_END
                                 
                                  PRINT_HAND_SCISSORS:
                                     ; Print to LCD
00021b e0f5                          ldi     ZH, high(STRING_SCISSORS<<1)
00021c eee8                          ldi     ZL, low(STRING_SCISSORS<<1)
00021d de91                          rcall   LCD_TOP
                                 
                                     ; Jump to end
00021e c000                          rjmp    PRINT_HAND_END
                                 
                                  PRINT_HAND_END:
                                     ; Restore variables
00021f 91ef                          pop     ZL
000220 91ff                          pop     ZH
000221 91af                          pop     XL
000222 91bf                          pop     XH
000223 910f                          pop     mpr
000224 9508                          ret
                                 
                                 CYCLE_HAND:
                                     ;-----------------------------------------------------------
                                     ; Func: Cycle hand
                                     ; Desc: Cycles the user's hand through the three avaiable options
                                     ;       and updates the LCD accordingly
                                     ;-----------------------------------------------------------
                                     ; Save variables
000225 930f                          push    mpr
000226 93bf                          push    XH
000227 93af                          push    XL
000228 93ff                          push    ZH
000229 93ef                          push    ZL
                                 
                                     ; Load in HAND_USER
00022a e0b2                          ldi     XH, high(HAND_USER)
00022b e0a3                          ldi     XL, low(HAND_USER)
00022c 910c                          ld      mpr, X
                                 
                                     ; Change hand based on current hand
00022d 3001                          cpi     mpr, SIGNAL_ROCK
00022e f059                          breq    CYCLE_HAND_PAPER
00022f 3002                          cpi     mpr, SIGNAL_PAPER
000230 f079                          breq    CYCLE_HAND_SCISSORS
000231 3003                          cpi     mpr, SIGNAL_SCISSORS
000232 f009                          breq    CYCLE_HAND_ROCK
                                 
                                     ; If no compare match, jump to end
000233 c012                          rjmp    CYCLE_HAND_END
                                 
                                  CYCLE_HAND_ROCK:                           ; Change to ROCK
                                     ; Change Data Memory variable HAND_USER
000234 e001                          ldi     mpr, SIGNAL_ROCK
000235 930c                          st      X, mpr
                                 
                                     ; Print to LCD
000236 e0f5                          ldi     ZH, high(STRING_ROCK<<1)        ; Point Z to string
000237 ece8                          ldi     ZL, low(STRING_ROCK<<1)         ; ^
000238 de88                          rcall   LCD_BOTTOM
                                 
                                     ; Jump to end
000239 c00c                          rjmp    CYCLE_HAND_END
                                 
                                  CYCLE_HAND_PAPER:                          ; Change to PAPER
                                     ; Change Data Memory variable HAND_USER
00023a e002                          ldi     mpr, SIGNAL_PAPER
00023b 930c                          st      X, mpr
                                 
                                     ; Print to LCD
00023c e0f5                          ldi     ZH, high(STRING_PAPER<<1)       ; Point Z to string
00023d ede8                          ldi     ZL, low(STRING_PAPER<<1)        ; ^
00023e de82                          rcall   LCD_BOTTOM
                                 
                                     ; Jump to end
00023f c006                          rjmp    CYCLE_HAND_END
                                 
                                  CYCLE_HAND_SCISSORS:                       ; Change to SCISSORS
                                     ; Change Data Memory variable HAND_USER
000240 e003                          ldi     mpr, SIGNAL_SCISSORS
000241 930c                          st      X, mpr
                                 
                                     ; Print to LCD
000242 e0f5                          ldi     ZH, high(STRING_SCISSORS<<1)    ; Point Z to string
000243 eee8                          ldi     ZL, low(STRING_SCISSORS<<1)     ; ^
000244 de7c                          rcall   LCD_BOTTOM
                                 
                                     ; Jump to end
000245 c000                          rjmp    CYCLE_HAND_END
                                 
                                  CYCLE_HAND_END:
                                     ; Clear interrupt queue
000246 d04d                          rcall   BUSY_WAIT
000247 ef0f                          ldi     mpr, 0b1111_1111
000248 bb0c                          out     EIFR, mpr
                                 
                                     ; Restore variables
000249 91ef                          pop     ZL
00024a 91ff                          pop     ZH
00024b 91af                          pop     XL
00024c 91bf                          pop     XH
00024d 910f                          pop     mpr
                                 
                                     ; Return from function
00024e 9508                          ret
                                 
                                 TIMER:
                                     ;-----------------------------------------------------------
                                     ; Func: Timer
                                     ; Desc: Starts the timer for a delay of 1.5 seconds and updates
                                     ;       PORTB upper 4 LEDs to show the time remaining. Once the
                                     ;       6 seconds are completed (4 subsequent calls TIMER) the 
                                     ;       TOV01 flag is disabled. 
                                     ;-----------------------------------------------------------
                                     ; Save variables
00024f 930f                          push    mpr
000250 93bf                          push    XH
000251 93af                          push    XL
                                 
000252 e408                          ldi     mpr, $48        ; Write to high byte first
000253 9300 0085                     sts     TCNT1H, mpr     ; ^
000255 ee05                          ldi     mpr, $E5        ; Write to low byte second
000256 9300 0084                     sts     TCNT1L, mpr     ; ^
                                 
                                     ; Load in TIMER_STAGE
000258 e0b2                          ldi     XH, high(TIMER_STAGE)
000259 e0a0                          ldi     XL, low(TIMER_STAGE)
00025a 910c                          ld      mpr, X
                                 
                                     ; Branch based on current TIMER_STAGE
00025b 3004                          cpi     mpr, 4
00025c f049                          breq    TIMER_4
00025d 3003                          cpi     mpr, 3
00025e f089                          breq    TIMER_3
00025f 3002                          cpi     mpr, 2
000260 f0b1                          breq    TIMER_2
000261 3001                          cpi     mpr, 1
000262 f0d9                          breq    TIMER_1
000263 3000                          cpi     mpr, 0
000264 f101                          breq    TIMER_0
                                 
                                     ; If no compare match, branch to end
000265 c02a                          rjmp    TIMER_END
                                 
                                  TIMER_4:                        ; Start timer
000266 e001                          ldi     mpr, (1<<TOIE1)     ; TOIE1 = 1 = Overflow Interrupt Enabled
000267 9300 006f                     sts     TIMSK1, mpr         ; ^
000269 e003                          ldi     mpr, 3              ; Update TIMER_STAGE
00026a 930c                          st      X, mpr              ; ^
00026b b103                          in      mpr, PINB           ; Update LEDs
00026c 700f                          andi    mpr, 0b0000_1111    ; ^
00026d 6f00                          ori     mpr, 0b1111_0000    ; ^
00026e b905                          out     PORTB, mpr          ; ^
00026f c020                          rjmp    TIMER_END           ; Jump to end
                                 
                                  TIMER_3:
000270 e002                          ldi     mpr, 2              ; Update TIMER_STAGE
000271 930c                          st      X, mpr              ; ^
000272 b103                          in      mpr, PINB           ; Update LEDs
000273 700f                          andi    mpr, 0b0000_1111    ; ^
000274 6700                          ori     mpr, 0b0111_0000    ; ^
000275 b905                          out     PORTB, mpr          ; ^
000276 c019                          rjmp    TIMER_END           ; Jump to end
                                 
                                  TIMER_2:
000277 e001                          ldi     mpr, 1              ; Update TIMER_STAGE
000278 930c                          st      X, mpr              ; ^
000279 b103                          in      mpr, PINB           ; Update LEDs
00027a 700f                          andi    mpr, 0b0000_1111    ; ^
00027b 6300                          ori     mpr, 0b0011_0000    ; ^
00027c b905                          out     PORTB, mpr          ; ^
00027d c012                          rjmp    TIMER_END           ; Jump to end
                                 
                                  TIMER_1:
00027e e000                          ldi     mpr, 0              ; Update TIMER_STAGE
00027f 930c                          st      X, mpr              ; ^
000280 b103                          in      mpr, PINB           ; Update LEDs
000281 700f                          andi    mpr, 0b0000_1111    ; ^
000282 6100                          ori     mpr, 0b0001_0000    ; ^
000283 b905                          out     PORTB, mpr          ; ^
000284 c00b                          rjmp    TIMER_END           ; Jump to end
                                 
                                  TIMER_0:                        ; End timer
000285 e000                          ldi     mpr, (0<<TOIE1)     ; TOIE1 = 0 = Overflow Interrupt Disabled
000286 9300 006f                     sts     TIMSK1, mpr         ; ^
000288 e004                          ldi     mpr, 4              ; Update TIMER_STAGE, so it wraps around and next time it begins at the start
000289 930c                          st      X, mpr              ; ^
00028a b103                          in      mpr, PINB           ; Update LEDs
00028b 700f                          andi    mpr, 0b0000_1111    ; ^
00028c 6000                          ori     mpr, 0b0000_0000    ; ^
00028d b905                          out     PORTB, mpr          ; ^
00028e dea5                          rcall   NEXT_GAME_STAGE     ; Update GAME_STAGE
00028f c000                          rjmp    TIMER_END           ; Jump to end
                                 
                                  TIMER_END:
                                     ; Restore variables
000290 91af                          pop     XL
000291 91bf                          pop     XH
000292 910f                          pop     mpr
                                 
                                     ; Return from function
000293 9508                          ret
                                 
                                 BUSY_WAIT:
                                     ;----------------------------------------------------------------
                                     ; Func: BUSY_WAIT
                                     ; Desc: A wait loop that is 16 + 159975*waitcnt cycles or roughly
                                     ;       mpr*10ms.  Just initialize wait for the specific amount
                                     ;       of time in 10ms intervals. Here is the general eqaution
                                     ;       for the number of clock cycles in the wait loop:
                                     ;       ((3 * ilcnt + 3) * olcnt + 3) * mpr + 13 + call
                                     ;----------------------------------------------------------------
                                     ; Save variables
000294 930f                          push    mpr
000295 932f                          push    ilcnt
000296 933f                          push    olcnt
                                     
000297 e00f                          ldi     mpr, 15
                                  BUSY_WAIT_LOOP:
000298 ee30                          ldi     olcnt, 224      ; Load olcnt register
                                  BUSY_WAIT_OLOOP:
000299 ee2d                          ldi     ilcnt, 237      ; Load ilcnt register
                                  BUSY_WAIT_ILOOP:
00029a 952a                          dec     ilcnt           ; Decrement ilcnt
00029b f7f1                          brne    BUSY_WAIT_ILOOP ; Continue Inner Loop
00029c 953a                          dec     olcnt           ; Decrement olcnt
00029d f7d9                          brne    BUSY_WAIT_OLOOP ; Continue Outer Loop
00029e 950a                          dec     mpr
00029f f7c1                          brne    BUSY_WAIT_LOOP
                                 
                                     ; Restore variables
0002a0 913f                          pop     olcnt
0002a1 912f                          pop     ilcnt
0002a2 910f                          pop     mpr
                                 
                                     ; Return from function
0002a3 9508                          ret
                                 
                                 ;***********************************************************
                                 ;*  Stored Program Data
                                 ;***********************************************************
                                 STRING_IDLE:
0002a4 6557
0002a5 636c
0002a6 6d6f
0002a7 2165
0002a8 2020
0002a9 2020
0002aa 2020
0002ab 2020
0002ac 6c50
0002ad 6165
0002ae 6573
0002af 7020
0002b0 6572
0002b1 7373
0002b2 5020
0002b3 3744                              .DB "Welcome!        Please press PD7"
                                 STRING_READY_UP:
0002b4 6552
0002b5 6461
0002b6 2e79
0002b7 5720
0002b8 6961
0002b9 6974
0002ba 676e
0002bb 2020
0002bc 6f66
0002bd 2072
0002be 6874
0002bf 2065
0002c0 706f
0002c1 6f70
0002c2 656e
0002c3 746e                              .DB "Ready. Waiting  for the opponent"
                                 STRING_CHOOSE_HAND:
0002c4 6843
0002c5 6f6f
0002c6 6573
0002c7 7920
0002c8 756f
0002c9 2072
0002ca 6168
0002cb 646e                              .DB "Choose your hand"
                                 STRING_WON:
0002cc 6f59
0002cd 2075
0002ce 6957
0002cf 216e
0002d0 2020
0002d1 2020
0002d2 2020
0002d3 2020                              .DB "You Win!        "
                                 STRING_LOST:
0002d4 6f59
0002d5 2075
0002d6 6f4c
0002d7 6573
0002d8 2021
0002d9 2020
0002da 2020
0002db 2020                              .DB "You Lose!       "
                                 STRING_DRAW:
0002dc 7244
0002dd 7761
0002de 2020
0002df 2020
0002e0 2020
0002e1 2020
0002e2 2020
0002e3 2020                              .DB "Draw            "
                                 STRING_ROCK:
0002e4 6f52
0002e5 6b63
0002e6 2020
0002e7 2020
0002e8 2020
0002e9 2020
0002ea 2020
0002eb 2020                              .DB "Rock            "
                                 STRING_PAPER:
0002ec 6150
0002ed 6570
0002ee 2072
0002ef 2020
0002f0 2020
0002f1 2020
0002f2 2020
0002f3 2020                              .DB "Paper           "
                                 STRING_SCISSORS:
0002f4 6353
0002f5 7369
0002f6 6f73
0002f7 2072
0002f8 2020
0002f9 2020
0002fa 2020
0002fb 2020                              .DB "Scissor         "
                                 
                                 ;***********************************************************
                                 ;*  Data Memory Allocation
                                 ;***********************************************************
                                 .dseg
                                 .org    $0200
                                 TIMER_STAGE:        ; TIMER_STAGE value for timer loop and LED display
000200                               .byte 1
                                 GAME_STAGE:         ; Indicates the current stage the game is in
000201                               .byte 1
                                 HAND_OPNT:          ; Opponent choice: Rock / Paper / Scissors
000202                               .byte 1
                                 HAND_USER:          ; User choice: Rock / Paper / Scissors
000203                               .byte 1
                                 READY_OPNT:         ; Opponent ready
000204                               .byte 1
                                 READY_USER:         ; User ready
000205                               .byte 1
                                 
                                 ;***********************************************************
                                 ;*  Additional Program Includes
                                 ;***********************************************************
                                 .include "LCDDriver.asm"
                                 
                                 ;*	Oregon State University
                                 ;*	ST7565R LCD Driver
                                 ;*	This code configures the graphical LCD and emulates
                                 ;*	the behavior of a 2x16 character display.
                                 ;*
                                 ;*	The LCD has room for 32 characters in total
                                 ;*	(16 on the top and 16 on the bottom).
                                 ;*	The upper 16 characters should be located in SRAM starting at 0x0100.
                                 ;*	The lower 16 characters should be located in SRAM starting at 0x0110.
                                 ;*
                                 ;*	NOTE: Register r16 MUST be named 'mpr' in the Main Code
                                 ;*	Something like this:
                                 ;*	.def	mpr = r16
                                 ;*
                                 ;*	WARNING: Register r20-r22 are reserved and cannot be
                                 ;*		renamed outside of the LCD Driver functions. Doing
                                 ;*		so will damage the functionality of the LCD Driver
                                 ;*
                                 ;*	Acknowledgements: the Bin2ASCII and div10 procedures were written by
                                 ;*	David Zier for a previous board. The code has been retained intact.
                                 ;*
                                 ;*********************************************************************
                                 ;*	Rev	Date		Name			Description
                                 ;*--------------------------------------------------------------------
                                 ;*	-	8/18/22	Justin Goins	Version 1.0
                                 ;*
                                 ;*
                                 ;*********************************************************************
                                 
                                 .include "m32U4def.inc"				; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Register definitions
                                 .def	count = r20			; Character Counter
                                 .def	q = r21			; Quotient for div10
                                 .def	r = r22			; Remander for div10
                                 
                                 ; The following constants are not intended to be modified.
                                 .equ	lcd_buffer_addr = 0x0100 ; define the SRAM base address of the LCD buffer
                                 
                                 ; This information is gathered from the ST7565R datasheet.
                                 ; define some command patterns
                                 .equ	lcd_c_disp_en = 0b10101110 ; lsb indicates whether the LCD is on (1) or off (0)
                                 .equ	lcd_c_disp_set_start_ln = 0b01000000 ; lower 6 bits indicate the line index (0 - 63)
                                 .equ	lcd_c_disp_set_page_addr = 0b10110000 ; lower 4 bits indicate the page address (page 3 is at top and page 0 is at bottom)
                                 ; together, these commands allow you to specify a column index from (0 - 131):
                                 .equ	lcd_c_disp_set_col_addr_h = 0b00010000 ; lower 4 bits indicate the 4 high bits of the column address
                                 .equ	lcd_c_disp_set_col_addr_l = 0b00000000 ; lower 4 bits indicate the 4 low bits of the column address
                                 .equ	lcd_c_disp_set_invert = 0b10100110 ; lsb indicates whether the LCD is normal (0) or inverted (1)
                                 .equ	lcd_c_disp_fill = 0b10100100 ; lsb indicates whether the LCD is normal (0) or filled with dots (1)
                                 .equ	lcd_c_disp_reset = 0b11100010 ; resets the line/page addresses and other stuff, does not affect data RAM
                                 .equ	lcd_c_disp_set_bias = 0xA2 ; 1/6 bias (in 1/33 duty mode)
                                 .equ	lcd_c_disp_set_scandir = 0b11000000 ; select normal scan direction (most significant bit is placed at top of LCD)
                                 .equ	lcd_c_disp_set_contrast_1 = 0b10000001 ; first we send this command then we pass the value
                                 .equ	lcd_c_disp_set_contrast_2 = 15 ; can select a contrast value between 1 and 63
                                 .equ	lcd_c_disp_set_res_ratio = 0x22 ; see the datasheet
                                 .equ	lcd_c_disp_vreg_on = 0x2F ; enable voltage booster, voltage regulator, and voltage follower
                                 
                                 ; use this command to write into the LCD RAM:
                                 .equ	lcd_c_disp_write = 0b00000000 ; these 8 bits are the data to be placed in the target. 
                                 ; note that the column address is automatically incremented by 1 after each write to the LCD data
                                 
                                 ; everything in this driver file needs to go into the code segment
                                 .cseg
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDInit
                                 ;* Desc:	This function initializes the LCD control pins and
                                 ;*		sets reasonable values for the configuration registers.
                                 ;*****************************************************************
                                 LCDInit:
0002fc 930f                      	push	mpr
                                 
                                 	; set MOSI, SCL, and SS as outputs
0002fd 9a22                      	sbi	DDRB, DDB2	; Port B 2
0002fe 9a21                      	sbi	DDRB, DDB1	; Port B 1
0002ff 9a20                      	sbi	DDRB, DDB0	; Port B 0
                                 	; ensure that SS is deactivated (active low)
000300 9a28                      	sbi	PORTB, 0
                                 	; set lcd_A0 as output
000301 9a81                      	sbi	DDRF, DDF1	; Port F 1
                                 	; enable LCD backlight control
000302 9a3f                      	sbi	DDRC, DDC7	; Port C 7
                                 	; set lcd_RST_N as output
000303 9a80                      	sbi	DDRF, DDF0	; Port F 0
                                 	; we pull lcd_RST_N low for 1 millisecond
000304 9888                      	cbi	PORTF, 0
000305 940e 03e7                 	call	LCDDelay
000307 9a88                      	sbi	PORTF, 0
                                 	; Enable SPI mode 3, master configuration, set clock rate fck/2 using SPI2X
000308 e50c                      	ldi	mpr, (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)
000309 bd0c                      	out	SPCR, mpr
00030a e001                      	ldi	mpr, (1<<SPI2X)
00030b bd0d                      	out	SPSR, mpr
                                 	; Note: after transmitting a byte, the SPI interrupt flag will
                                 	; be automatically cleared next time we: 1) read SPSR and ALSO 2) access SPDR
                                 
00030c 9828                      	cbi	PORTB, 0	; activate slave select
                                 	; send a string of initialization commands
00030d ea02                      	ldi	mpr, lcd_c_disp_set_bias
00030e d0d2                      	rcall	LCD_Internal_WriteCMD
00030f ec00                      	ldi	mpr, lcd_c_disp_set_scandir
000310 d0d0                      	rcall	LCD_Internal_WriteCMD
000311 e801                      	ldi	mpr, lcd_c_disp_set_contrast_1
000312 d0ce                      	rcall	LCD_Internal_WriteCMD
000313 e00f                      	ldi	mpr, lcd_c_disp_set_contrast_2
000314 d0cc                      	rcall	LCD_Internal_WriteCMD
000315 e202                      	ldi	mpr, lcd_c_disp_set_res_ratio
000316 d0ca                      	rcall	LCD_Internal_WriteCMD
000317 e20f                      	ldi	mpr, lcd_c_disp_vreg_on
000318 d0c8                      	rcall	LCD_Internal_WriteCMD
000319 ea0f                      	ldi	mpr, (lcd_c_disp_en | 1 << 0)
00031a d0c6                      	rcall	LCD_Internal_WriteCMD
00031b 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
00031c 910f                      	pop	mpr
00031d 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOn
                                 ;* Desc:	Enables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOn:
00031e 9a47                      	sbi	PORTC, 7
00031f 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOff
                                 ;* Desc:	Disables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOff:
000320 9847                      	cbi	PORTC, 7
000321 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrite
                                 ;* Desc:	This function writes 32 characters to the LCD screen...
                                 ;*		16 chars on the top line and 16 chars on the bottom line.
                                 ;*****************************************************************
                                 LCDWrite:
000322 d002                      	rcall	LCDWrLn1
000323 d00c                      	rcall	LCDWrLn2
000324 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn1
                                 ;* Desc:	This function writes 16 characters to the top line.
                                 ;*****************************************************************
                                 LCDWrLn1:
000325 93bf                      	push	XH
000326 93af                      	push	XL
000327 931f                      	push	r17
                                 	; r17 specifies the destination bank in LCD RAM
000328 e013                      	ldi	r17, 3
                                 	; point X at the ASCII data
000329 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr)
00032a e0a0                      	ldi	XL, LOW(lcd_buffer_addr)
00032b d05c                      	rcall	LCD_Internal_WriteLn
00032c 911f                      	pop	r17
00032d 91af                      	pop	XL
00032e 91bf                      	pop	XH
00032f 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn2
                                 ;* Desc:	This function writes 16 characters to the bottom line.
                                 ;*****************************************************************
                                 LCDWrLn2:
000330 93bf                      	push	XH
000331 93af                      	push	XL
000332 931f                      	push	r17
                                 	; r17 specifies the destination bank in LCD RAM
000333 e011                      	ldi	r17, 1
                                 	; point X at the ASCII data
000334 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr+16)
000335 e1a0                      	ldi	XL, LOW(lcd_buffer_addr+16)
000336 d051                      	rcall	LCD_Internal_WriteLn
000337 911f                      	pop	r17
000338 91af                      	pop	XL
000339 91bf                      	pop	XH
00033a 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClr
                                 ;* Desc:	This function clears the entire LCD screen.
                                 ;*****************************************************************
                                 LCDClr:
00033b d022                      	rcall	LCDClrLn1
00033c d027                      	rcall	LCDClrLn2
                                 
00033d 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM1
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0100.
                                 ;*****************************************************************
                                 CLRDM1:
                                     ; Set X register points to $0100
00033e 93bf                      	   push	   XH
00033f 93af                      	   PUSH	   XL
000340 930f                                 push    r16
000341 931f                                 push    r17
                                 
000342 e0b1                                 ldi     XH, HIGH(lcd_buffer_addr)
000343 e0a0                                 ldi     XL, LOW(lcd_buffer_addr)
000344 e110                                 ldi     r17, 16
000345 e200                                 ldi     r16, ' '
                                    CLRloop1:
000346 930d                                 st      X+, r16         ; load data to DM
000347 951a                                 dec     r17
000348 f7e9                                 brne    CLRloop1
                                 
000349 911f                      	   pop	   r17
00034a 910f                      	   pop	   r16
00034b 91af                      	   pop	   XL
00034c 91bf                      	   pop	   XH
                                 
00034d 9508                                 ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM2
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0110.
                                 ;*****************************************************************
                                 CLRDM2:
                                     ; Set X register points to $0110
00034e 93bf                      	   push	   XH
00034f 93af                      	   PUSH	   XL
000350 930f                                 push    r16
000351 931f                                 push    r17
                                 
000352 e0b1                                 ldi     XH, HIGH(lcd_buffer_addr+16)
000353 e1a0                                 ldi     XL, LOW(lcd_buffer_addr+16)
000354 e110                                 ldi     r17, 16
000355 e200                                 ldi     r16, ' '
                                    CLRloop2:
000356 930d                                 st      X+, r16         ; load data to DM
000357 951a                                 dec     r17
000358 f7e9                                 brne    CLRloop2
                                 
000359 911f                      	   pop	   r17
00035a 910f                      	   pop	   r16
00035b 91af                      	   pop	   XL
00035c 91bf                      	   pop	   XH
                                 
00035d 9508                                 ret
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn1
                                 ;* Desc:	This function clears the top line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn1:
00035e 931f                      	push	r17
                                 	; r17 specifies the target bank in LCD RAM
00035f e013                      	ldi	r17, 3
000360 d060                      	rcall	LCD_Internal_ClearLn
000361 dfdc                      	rcall	CLRDM1
000362 911f                      	pop	r17
000363 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn2
                                 ;* Desc:	This function clears the bottom line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn2:
000364 931f                      	push	r17
                                 	; r17 specifies the target bank in LCD RAM
000365 e011                      	ldi	r17, 1
000366 d05a                      	rcall	LCD_Internal_ClearLn
000367 dfe6                      	rcall	CLRDM2
000368 911f                      	pop	r17
000369 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	Bin2ASCII
                                 ;* Desc:	Converts a binary number into an ASCII 
                                 ;*			text string equivalent. 
                                 ;*			- The binary number needs to be in the mpr
                                 ;*			- The Start Address of where the text will
                                 ;*			 	be placed needs to be in the X Register
                                 ;*			- The count of the characters created are 
                                 ;*				added to the count register
                                 ;*****************************************************************
                                 Bin2ASCII:
00036a 930f                      	push	mpr			; save mpr
00036b 936f                      	push	r			; save r
00036c 935f                      	push	q			; save q
00036d 93bf                      	push	XH			; save X-pointer
00036e 93af                      	push	XL			;
                                 
                                 	; Determine the range of mpr
00036f 3604                      	cpi	mpr, 100		; is mpr >= 100
000370 f018                      	brlo	B2A_1			; goto next check
000371 e043                      	ldi	count, 3		; Three chars are written
000372 9613                      	adiw	XL, 3			; Increment X 3 address spaces
000373 c007                      	rjmp	B2A_3			; Continue with program
                                 B2A_1:
000374 300a                      	cpi	mpr, 10		; is mpr >= 10
000375 f018                      	brlo	B2A_2			; Continue with program
000376 e042                      	ldi	count, 2		; Two chars are written
000377 9612                      	adiw	XL, 2			; Increment X 2 address spaces
000378 c002                      	rjmp	B2A_3			; Continue with program
                                 B2A_2:
000379 9611                      	adiw	XL, 1			; Increment X 1 address space
00037a e041                      	ldi	count, 1		; One char is written
                                 
                                 B2A_3:
                                 	; Do-While statement that converts Binary to ASCII
00037b d076                      	rcall	div10			; Call the div10 function
00037c e300                      	ldi	mpr, '0'		; Set the base ASCII integer value
00037d 0f06                      	add	mpr, r		; Create the ASCII integer value
00037e 930e                      	st	-X, mpr		; Load ASCII value to memory
00037f 2f05                      	mov	mpr, q		; Set mpr to quotient value
000380 3000                      	cpi	mpr, 0		; does mpr == 0
000381 f7c9                      	brne	B2A_3			; do while (mpr != 0)
                                 
000382 91af                      	pop	XL			; restore X-pointer
000383 91bf                      	pop	XH			;
000384 915f                      	pop	q			; restore q
000385 916f                      	pop	r			; restore r
000386 910f                      	pop	mpr			; restore mpr
000387 9508                      	ret				; return from function
                                 
                                 ;*****************************************************************
                                 ;*	The functions below here are intended for internal use only.
                                 ;*****************************************************************
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteLn
                                 ;* Desc:	Sends 16 characters of information to the LCD panel
                                 ;*		This is slightly more complicated than it sounds because the
                                 ;*		characters straddle two banks of the LCD memory.
                                 ;*		X is pointing at the first ASCII character to be displayed.
                                 ;*		r17 holds the index of the destination bank in LCD RAM.
                                 ;*		
                                 ;*****************************************************************
                                 LCD_Internal_WriteLn:
000388 920f                      	push	r0
000389 921f                      	push	r1
00038a 930f                      	push	mpr
00038b 932f                      	push	r18
00038c 933f                      	push	r19
00038d 938f                      	push	r24
00038e 939f                      	push	r25
00038f 93ef                      	push	ZL
000390 93ff                      	push	ZH
                                 
                                 	; r25:24 holds a pointer to the base address of the bitmap array
000391 e098                      	ldi	r25, HIGH(FontBitmap << 1);
000392 e380                      	ldi	r24, LOW(FontBitmap << 1);
                                 
000393 9828                      	cbi	PORTB, 0	; activate slave select
                                 
                                 	; use a counter to track if we are on the top chunk or bottom chunk of each char
000394 e022                      	ldi	r18, 2
                                 
                                 LCD_WL_display_bank:
                                 	; set the column to 0
000395 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
000396 d04a                      	rcall	LCD_Internal_WriteCMD
000397 e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
000398 d048                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
000399 eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
00039a 2b01                      	or	mpr, r17	; set the lower 4 bits
00039b d045                      	rcall	LCD_Internal_WriteCMD
                                 
00039c e130                      	ldi	r19, 16	; there are 16 characters per line
                                 
                                 LCD_WL_next_char:
                                 	; get ascii code point & determine location of corresponding character bitmap
00039d 900d                      	ld	r0, X+	; this should be a value from 0 to 255
00039e e100                      	ldi	mpr, 16	; there are 16 bytes per character
00039f 9e00                      	mul	r0, mpr	; determine the byte offset for the desired char
0003a0 01fc                      	movw	ZH:ZL, r25:r24	; copy the base address to Z
0003a1 0de0                      	add	ZL, r0	; finally, compute a pointer to the char bitmap
0003a2 1df1                      	adc	ZH, r1
                                 
0003a3 e008                      	ldi	mpr, 8	; there are 8 columns for each character
                                 
                                 	; this is where we display the chunk of character (either a top chunk or bottom chunk)
0003a4 9004                      	lpm	r0, Z
                                 LCD_WL_next_col:
0003a5 bc0e                      	out	SPDR, r0
0003a6 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
0003a7 9632                      	adiw	ZH:ZL, 2	; point Z at the next column for this bank
0003a8 9004                      	lpm	r0, Z		; this is a sneaky way to save a few clock cycles (since we are waiting for the SPI communication)
                                 LCD_WL_wait_spi:
0003a9 b41d                      	in	r1, SPSR
0003aa fe17                      	sbrs	r1, SPIF	; wait for SPI to finish
0003ab cffd                      	rjmp	LCD_WL_wait_spi
                                 
                                 	; keep going until we have displayed all the columns for this character
0003ac 950a                      	dec	mpr
0003ad f7b9                      	brne	LCD_WL_next_col
                                 
                                 	; move to the next character
0003ae 953a                      	dec	r19
0003af f769                      	brne	LCD_WL_next_char
                                 
                                 	; if we are at the end of the line, configure the bank and starting array offset for the bottom half of each char
0003b0 952a                      	dec	r18		; did we display both banks yet?
0003b1 f021                      	breq	LCD_WL_all_done
                                 	; if not, then prepare to display the bottom chunk of each character
0003b2 951a                      	dec	r17		; decrement the bank number
0003b3 9750                      	sbiw	XH:XL, 16	; X needs to point back at the beginning character of the line
0003b4 9601                      	adiw	r25:r24, 1	; increment the base address pointer (now it will point to the second chunk of each char)
0003b5 cfdf                      	rjmp	LCD_WL_display_bank
                                 
                                 LCD_WL_all_done:
0003b6 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
0003b7 91ff                      	pop	ZH
0003b8 91ef                      	pop	ZL
0003b9 919f                      	pop	r25
0003ba 918f                      	pop	r24
0003bb 913f                      	pop	r19
0003bc 912f                      	pop	r18
0003bd 910f                      	pop	mpr
0003be 901f                      	pop	r1
0003bf 900f                      	pop	r0
0003c0 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_ClearLn
                                 ;* Desc:	This function clears two of the LCD memory banks.
                                 ;*		r17 specifies the starting bank to wipe.
                                 ;*****************************************************************
                                 LCD_Internal_ClearLn:
0003c1 930f                      	push	mpr
0003c2 921f                      	push	r1
0003c3 932f                      	push	r18
0003c4 933f                      	push	r19
                                 
0003c5 9828                      	cbi	PORTB, 0	; activate slave select
0003c6 e032                      	ldi	r19, 2	; we are going to clear two banks
                                 
                                 LCD_CLRLN_clear_bank:
                                 	; set the column to 0
0003c7 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
0003c8 d018                      	rcall	LCD_Internal_WriteCMD
0003c9 e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
0003ca d016                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
0003cb eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
0003cc 2b01                      	or	mpr, r17	; configure the lower 4 bits
0003cd d013                      	rcall	LCD_Internal_WriteCMD
                                 
0003ce e820                      	ldi	r18, 128	; there are 128 columns on the LCD
0003cf 2700                      	clr	mpr		; we will fill each column with empty dots (i.e. blank space)
0003d0 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
                                 
                                 LCD_CLRLN_write_col:
0003d1 bd0e                      	out	SPDR, mpr	; send an empty column to the LCD via SPI
                                 LCD_CLRLN_wait_spi:
0003d2 b41d                      	in	r1, SPSR
0003d3 fe17                      	sbrs	r1, SPIF	; wait for SPI to finish
0003d4 cffd                      	rjmp	LCD_CLRLN_wait_spi
                                 
0003d5 952a                      	dec	r18
0003d6 f7d1                      	brne	LCD_CLRLN_write_col	; cycle through all 128 columns
                                 
                                 	; clear the remaining bank if we haven't done so already
0003d7 953a                      	dec	r19
0003d8 f011                      	breq	LCD_CLRLN_all_done
0003d9 951a                      	dec	r17		; decrement the bank index
0003da cfec                      	rjmp	LCD_CLRLN_clear_bank
                                 
                                 LCD_CLRLN_all_done:
0003db 9a28                      	sbi	PORTB, 0	; deactivate slave select	
                                 	
                                 	; pop registers...
0003dc 913f                      	pop	r19
0003dd 912f                      	pop	r18
0003de 901f                      	pop	r1
0003df 910f                      	pop	mpr
0003e0 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteCMD
                                 ;* Desc:	Sends the byte in mpr
                                 ;*		If you use this function directly,
                                 ;*		YOU ARE RESPONSIBLE for handling the slave select line!
                                 ;*****************************************************************
                                 LCD_Internal_WriteCMD:
0003e1 bd0e                      	out	SPDR, mpr	; initiate transmission
0003e2 9889                      	cbi	PORTF, 1	; clear lcd_A0 to put the lcd into command mode
                                 				; (this just has to be done before the 8th bit
                                 				; is transmitted via SPI)
                                 LCD_IWC_L1:
0003e3 b50d                      	in	mpr, SPSR
0003e4 ff07                      	sbrs	mpr, SPIF	; wait for SPI to finish
0003e5 cffd                      	rjmp LCD_IWC_L1
0003e6 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDDelay
                                 ;* Desc:	A wait loop that will consume roughly 1ms
                                 ;*		Note that a CALL takes 4 cycles on top of this delay.
                                 ;*****************************************************************
                                 LCDDelay:
0003e7 930f                      	push	mpr		; 2 cycles
0003e8 931f                      	push	r17		; 2 cycles
0003e9 e01b                      	ldi	r17, 11	; 1 cycle
                                 LCDDelay_L1:
0003ea ef02                      	ldi	mpr, 242	; 1 cycle
                                 LCDDelay_L2:
0003eb 950a                      	dec	mpr		; 1 cycle
0003ec f7f1                      	brne	LCDDelay_L2	; 2 cycles on branch, 1 if no branch
0003ed 951a                      	dec	r17		; 1 cycle
0003ee f7d9                      	brne	LCDDelay_L1	; 2 cycles on branch, 1 if no branch
0003ef 911f                      	pop	r17		; 2 cycles
0003f0 910f                      	pop	mpr		; 2 cycles
0003f1 9508                      	ret			; 4 cycles
                                 
                                 ;*****************************************************************
                                 ;* Func:	div10
                                 ;* Desc:	Divides the value in the mpr by 10 and 
                                 ;*			puts the remainder in the 'r' register
                                 ;*			and the quotient in the 'q' register.
                                 ;*	DO NOT modify this function, trust me, it does
                                 ;*	divide by 10 :)  ~DZ		
                                 ;*****************************************************************
                                 div10:
0003f2 920f                      	push	r0		; Save register
                                 
                                 	; q = mpr / 10 = mpr * 0.000110011001101b
0003f3 2f50                      	mov	q, mpr	; q = mpr * 1.0b
0003f4 9556                      	lsr	q		; q >> 2
0003f5 9556                      	lsr	q		; q = mpr * 0.01b
0003f6 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003f7 9556                      	lsr	q		; q = mpr * 0.101b
0003f8 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
0003f9 9556                      	lsr	q
0003fa 9556                      	lsr	q
0003fb 9556                      	lsr	q		; q = mpr * 0.001101b
0003fc 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003fd 9556                      	lsr	q		; q = mpr * 0.1001101b
0003fe 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
0003ff 9556                      	lsr	q				
000400 9556                      	lsr	q
000401 9556                      	lsr	q		; q = mpr * 0.0011001101b
000402 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
000403 9556                      	lsr	q		; q = mpr * 0.10011001101b
000404 0f50                      	add	q, mpr	; q = (q + mpr) >> 4
000405 9556                      	lsr	q
000406 9556                      	lsr	q
000407 9556                      	lsr	q
000408 9556                      	lsr	q		; q = mpr * 0.000110011001101b
                                 
                                 	; compute the remainder as r = i - 10 * q
                                 	; calculate r = q * 10 = q * 1010b
000409 2f65                      	mov	r, q		; r = q * 1
00040a 0f66                      	lsl	r		; r << 2
00040b 0f66                      	lsl	r		; r = q * 100b
00040c 0f65                      	add	r, q		; r = (r + q) << 1
00040d 0f66                      	lsl	r		; r = q * 1010b
00040e 2e06                      	mov	r0, r		; r0 = 10 * q
00040f 2f60                      	mov	r, mpr	; r = mpr
000410 1960                      	sub	r, r0		; r = mpr - 10 * q
                                 
                                 	; Fix any errors that occur
                                 div10_1:
000411 306a                      	cpi	r, 10		; Compare with 10
000412 f018                      	brlo	div10_2	; do nothing if r < 10
000413 9553                      	inc	q		; fix quotient
000414 506a                      	subi	r, 10		; fix remainder
000415 cffb                      	rjmp	div10_1	; Continue until error is corrected
                                 
                                 div10_2:
000416 900f                      	pop	r0		; Restore registers
000417 9508                      	ret			; Return from function
                                 
                                 ;*********************************************************************
                                 ;*	Bitmap Font Information
                                 ;*	Adapted into assembly code by Justin Goins.
                                 ;*	You can edit characters or add symbols if you choose (by modifying the data below)
                                 ;*	Each character is represented as a 8 x 16 pattern of dots (8 dots wide and 16 dots high).
                                 ;*	This implies that 16 bytes are allocated to represent each character.
                                 ;*
                                 ;*	The character information is arranged so that each line below equates to a single character.
                                 ;*	The first line is ASCII character 0, the next line is ASCII character 1,
                                 ;*	the next line is ASCII character 2, and so on.
                                 ;*	You can assign characters to any index within the extended ASCII range (0 to 255).
                                 ;*	With a bit of experimentation it's possible to define and display emojis (or any other graphical output).
                                 ;*	Be creative and have fun!
                                 ;*
                                 ;*	From original license file:
                                 ;*	Copyright 2011 Suraj N. Kurapati <https://github.com/sunaku/tamzen-font>
                                 ;*	Tamzen font is free.  You are hereby granted permission to use, copy, modify, and distribute it as you see fit.
                                 ;*	Tamzen font is provided "as is" without any express or implied warranty.
                                 ;*********************************************************************
                                 FontBitmap:
000418 0000
000419 f00f
00041a 1008
00041b 1008
00041c 1008
00041d 1008
00041e f00f
00041f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x00, 0x00	; U+0000
000420 fe03
000421 fa7f
000422 f683
000423 ea83
000424 d683
000425 aa83
000426 567f
000427 fe03                      .DB	0x03, 0xFE, 0x7F, 0xFA, 0x83, 0xF6, 0x83, 0xEA, 0x83, 0xD6, 0x83, 0xAA, 0x7F, 0x56, 0x03, 0xFE	; U+E0A2
000428 5455
000429 aaaa
00042a 5455
00042b aaaa
00042c 5455
00042d aaaa
00042e 5455
00042f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; U+2592
000430 5455
000431 aaaa
000432 5455
000433 aaaa
000434 5455
000435 aaaa
000436 5455
000437 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000438 5455
000439 aaaa
00043a 5455
00043b aaaa
00043c 5455
00043d aaaa
00043e 5455
00043f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000440 5455
000441 aaaa
000442 5455
000443 aaaa
000444 5455
000445 aaaa
000446 5455
000447 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000448 5455
000449 aaaa
00044a 5455
00044b aaaa
00044c 5455
00044d aaaa
00044e 5455
00044f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000450 0000
000451 0007
000452 8008
000453 8008
000454 8008
000455 0007
000456 0000
000457 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
000458 5455
000459 aaaa
00045a 5455
00045b aaaa
00045c 5455
00045d aaaa
00045e 5455
00045f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000460 5455
000461 aaaa
000462 5455
000463 aaaa
000464 5455
000465 aaaa
000466 5455
000467 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000468 5455
000469 aaaa
00046a 5455
00046b aaaa
00046c 5455
00046d aaaa
00046e 5455
00046f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000470 8000
000471 8000
000472 8000
000473 8000
000474 80ff
000475 0000
000476 0000
000477 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2518
000478 8000
000479 8000
00047a 8000
00047b 8000
00047c fe00
00047d 0000
00047e 0000
00047f 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2510
000480 0000
000481 0000
000482 0000
000483 0000
000484 fe00
000485 8000
000486 8000
000487 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+250C
000488 0000
000489 0000
00048a 0000
00048b 0000
00048c 80ff
00048d 8000
00048e 8000
00048f 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2514
000490 8000
000491 8000
000492 8000
000493 8000
000494 feff
000495 8000
000496 8000
000497 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+253C
000498 5455
000499 aaaa
00049a 5455
00049b aaaa
00049c 5455
00049d aaaa
00049e 5455
00049f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004a0 5455
0004a1 aaaa
0004a2 5455
0004a3 aaaa
0004a4 5455
0004a5 aaaa
0004a6 5455
0004a7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004a8 8000
0004a9 8000
0004aa 8000
0004ab 8000
0004ac 8000
0004ad 8000
0004ae 8000
0004af 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2500
0004b0 5455
0004b1 aaaa
0004b2 5455
0004b3 aaaa
0004b4 5455
0004b5 aaaa
0004b6 5455
0004b7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004b8 5455
0004b9 aaaa
0004ba 5455
0004bb aaaa
0004bc 5455
0004bd aaaa
0004be 5455
0004bf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004c0 0000
0004c1 0000
0004c2 0000
0004c3 0000
0004c4 feff
0004c5 8000
0004c6 8000
0004c7 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+251C
0004c8 8000
0004c9 8000
0004ca 8000
0004cb 8000
0004cc feff
0004cd 0000
0004ce 0000
0004cf 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2524
0004d0 8000
0004d1 8000
0004d2 8000
0004d3 8000
0004d4 80ff
0004d5 8000
0004d6 8000
0004d7 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2534
0004d8 8000
0004d9 8000
0004da 8000
0004db 8000
0004dc fe00
0004dd 8000
0004de 8000
0004df 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+252C
0004e0 0000
0004e1 0000
0004e2 0000
0004e3 0000
0004e4 feff
0004e5 0000
0004e6 0000
0004e7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2502
0004e8 5455
0004e9 aaaa
0004ea 5455
0004eb aaaa
0004ec 5455
0004ed aaaa
0004ee 5455
0004ef aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004f0 5455
0004f1 aaaa
0004f2 5455
0004f3 aaaa
0004f4 5455
0004f5 aaaa
0004f6 5455
0004f7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004f8 5455
0004f9 aaaa
0004fa 5455
0004fb aaaa
0004fc 5455
0004fd aaaa
0004fe 5455
0004ff aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000500 5455
000501 aaaa
000502 5455
000503 aaaa
000504 5455
000505 aaaa
000506 5455
000507 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000508 0000
000509 1001
00050a 2001
00050b e007
00050c 2009
00050d 1009
00050e 1008
00050f 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
000510 5455
000511 aaaa
000512 5455
000513 aaaa
000514 5455
000515 aaaa
000516 5455
000517 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000518 0000
000519 0000
00051a 0000
00051b 0000
00051c 0000
00051d 0000
00051e 0000
00051f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0020
000520 0000
000521 0000
000522 0000
000523 301f
000524 0000
000525 0000
000526 0000
000527 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0021
000528 0000
000529 0000
00052a 001e
00052b 0000
00052c 0000
00052d 001e
00052e 0000
00052f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0022
000530 0000
000531 4002
000532 f00f
000533 4002
000534 4002
000535 f00f
000536 4002
000537 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x00, 0x00	; U+0023
000538 0000
000539 0000
00053a 2006
00053b 2009
00053c 3839
00053d 2009
00053e c008
00053f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x06, 0x20, 0x09, 0x20, 0x39, 0x38, 0x09, 0x20, 0x08, 0xC0, 0x00, 0x00	; U+0024
000540 0000
000541 200c
000542 4012
000543 8012
000544 600d
000545 9002
000546 9004
000547 6008                      .DB	0x00, 0x00, 0x0C, 0x20, 0x12, 0x40, 0x12, 0x80, 0x0D, 0x60, 0x02, 0x90, 0x04, 0x90, 0x08, 0x60	; U+0025
000548 0000
000549 e00c
00054a 1013
00054b 1013
00054c 900c
00054d 6000
00054e 6000
00054f 9001                      .DB	0x00, 0x00, 0x0C, 0xE0, 0x13, 0x10, 0x13, 0x10, 0x0C, 0x90, 0x00, 0x60, 0x00, 0x60, 0x01, 0x90	; U+0026
000550 0000
000551 0000
000552 0000
000553 001e
000554 0000
000555 0000
000556 0000
000557 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0027
000558 0000
000559 0000
00055a 0000
00055b e003
00055c 180c
00055d 0410
00055e 0000
00055f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x0C, 0x18, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00	; U+0028
000560 0000
000561 0000
000562 0410
000563 180c
000564 e003
000565 0000
000566 0000
000567 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x0C, 0x18, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0029
000568 0000
000569 8000
00056a a002
00056b c001
00056c c001
00056d a002
00056e 8000
00056f 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x02, 0xA0, 0x01, 0xC0, 0x01, 0xC0, 0x02, 0xA0, 0x00, 0x80, 0x00, 0x00	; U+002A
000570 0000
000571 8000
000572 8000
000573 8000
000574 f007
000575 8000
000576 8000
000577 8000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x07, 0xF0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+002B
000578 0000
000579 0000
00057a 0000
00057b 3200
00057c 3c00
00057d 0000
00057e 0000
00057f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002C
000580 0000
000581 8000
000582 8000
000583 8000
000584 8000
000585 8000
000586 8000
000587 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+002D
000588 0000
000589 0000
00058a 0000
00058b 3000
00058c 3000
00058d 0000
00058e 0000
00058f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002E
000590 0000
000591 0c00
000592 3000
000593 c000
000594 0003
000595 000c
000596 0000
000597 0000                      .DB	0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002F
000598 0000
000599 e007
00059a 5008
00059b 9008
00059c 1009
00059d 100a
00059e e007
00059f 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+0030
0005a0 0000
0005a1 0000
0005a2 1002
0005a3 1004
0005a4 f00f
0005a5 1000
0005a6 1000
0005a7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x04, 0x10, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0031
0005a8 0000
0005a9 1004
0005aa 3008
0005ab 5008
0005ac 9008
0005ad 1009
0005ae 1006
0005af 0000                      .DB	0x00, 0x00, 0x04, 0x10, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x06, 0x10, 0x00, 0x00	; U+0032
0005b0 0000
0005b1 2008
0005b2 1008
0005b3 1009
0005b4 100b
0005b5 100d
0005b6 e008
0005b7 0000                      .DB	0x00, 0x00, 0x08, 0x20, 0x08, 0x10, 0x09, 0x10, 0x0B, 0x10, 0x0D, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0033
0005b8 0000
0005b9 c000
0005ba 4001
0005bb 4002
0005bc 4004
0005bd f00f
0005be 4000
0005bf 0000                      .DB	0x00, 0x00, 0x00, 0xC0, 0x01, 0x40, 0x02, 0x40, 0x04, 0x40, 0x0F, 0xF0, 0x00, 0x40, 0x00, 0x00	; U+0034
0005c0 0000
0005c1 200f
0005c2 1009
0005c3 1009
0005c4 1009
0005c5 1009
0005c6 e008
0005c7 0000                      .DB	0x00, 0x00, 0x0F, 0x20, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0035
0005c8 0000
0005c9 e003
0005ca 1005
0005cb 1009
0005cc 1009
0005cd 1001
0005ce e000
0005cf 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x05, 0x10, 0x09, 0x10, 0x09, 0x10, 0x01, 0x10, 0x00, 0xE0, 0x00, 0x00	; U+0036
0005d0 0000
0005d1 0008
0005d2 0008
0005d3 3008
0005d4 c008
0005d5 000b
0005d6 000c
0005d7 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x30, 0x08, 0xC0, 0x0B, 0x00, 0x0C, 0x00, 0x00, 0x00	; U+0037
0005d8 0000
0005d9 e006
0005da 1009
0005db 1009
0005dc 1009
0005dd 1009
0005de e006
0005df 0000                      .DB	0x00, 0x00, 0x06, 0xE0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0038
0005e0 0000
0005e1 0007
0005e2 8008
0005e3 9008
0005e4 9008
0005e5 a008
0005e6 c007
0005e7 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x90, 0x08, 0x90, 0x08, 0xA0, 0x07, 0xC0, 0x00, 0x00	; U+0039
0005e8 0000
0005e9 0000
0005ea 0000
0005eb 3006
0005ec 3006
0005ed 0000
0005ee 0000
0005ef 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x06, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003A
0005f0 0000
0005f1 0000
0005f2 0000
0005f3 3206
0005f4 3c06
0005f5 0000
0005f6 0000
0005f7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003B
0005f8 0000
0005f9 0000
0005fa 8000
0005fb 4001
0005fc 2002
0005fd 1004
0005fe 0000
0005ff 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00	; U+003C
000600 0000
000601 4002
000602 4002
000603 4002
000604 4002
000605 4002
000606 4002
000607 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00	; U+003D
000608 0000
000609 0000
00060a 1004
00060b 2002
00060c 4001
00060d 8000
00060e 0000
00060f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+003E
000610 0000
000611 0008
000612 0010
000613 3011
000614 0012
000615 0014
000616 0008
000617 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x11, 0x30, 0x12, 0x00, 0x14, 0x00, 0x08, 0x00, 0x00, 0x00	; U+003F
000618 0000
000619 f007
00061a 0808
00061b c411
00061c 2412
00061d 2412
00061e 440a
00061f e407                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x08, 0x11, 0xC4, 0x12, 0x24, 0x12, 0x24, 0x0A, 0x44, 0x07, 0xE4	; U+0040
000620 0000
000621 f003
000622 8004
000623 8008
000624 8008
000625 8004
000626 f003
000627 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x04, 0x80, 0x08, 0x80, 0x08, 0x80, 0x04, 0x80, 0x03, 0xF0, 0x00, 0x00	; U+0041
000628 0000
000629 f00f
00062a 1009
00062b 1009
00062c 1009
00062d 1009
00062e e006
00062f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0042
000630 0000
000631 c003
000632 2004
000633 1008
000634 1008
000635 1008
000636 1008
000637 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0043
000638 0000
000639 f00f
00063a 1008
00063b 1008
00063c 1008
00063d 2004
00063e c003
00063f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+0044
000640 0000
000641 f00f
000642 1009
000643 1009
000644 1009
000645 1009
000646 1008
000647 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0045
000648 0000
000649 f00f
00064a 0009
00064b 0009
00064c 0009
00064d 0009
00064e 0008
00064f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00	; U+0046
000650 0000
000651 c003
000652 2004
000653 1008
000654 1008
000655 9008
000656 f008
000657 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x90, 0x08, 0xF0, 0x00, 0x00	; U+0047
000658 0000
000659 f00f
00065a 0001
00065b 0001
00065c 0001
00065d 0001
00065e f00f
00065f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x00, 0x00	; U+0048
000660 0000
000661 0000
000662 1008
000663 1008
000664 f00f
000665 1008
000666 1008
000667 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0049
000668 0000
000669 6000
00066a 1000
00066b 1000
00066c 1000
00066d 1000
00066e e00f
00066f 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+004A
000670 0000
000671 f00f
000672 8001
000673 8001
000674 4002
000675 2004
000676 1008
000677 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x10, 0x00, 0x00	; U+004B
000678 0000
000679 f00f
00067a 1000
00067b 1000
00067c 1000
00067d 1000
00067e 1000
00067f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+004C
000680 0000
000681 f00f
000682 0004
000683 0002
000684 8001
000685 0002
000686 0004
000687 f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x80, 0x02, 0x00, 0x04, 0x00, 0x0F, 0xF0	; U+004D
000688 0000
000689 f00f
00068a 0004
00068b 0002
00068c 0001
00068d 8000
00068e f00f
00068f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x0F, 0xF0, 0x00, 0x00	; U+004E
000690 0000
000691 e007
000692 1008
000693 1008
000694 1008
000695 1008
000696 e007
000697 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+004F
000698 0000
000699 f00f
00069a 8008
00069b 8008
00069c 8008
00069d 8008
00069e 0007
00069f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00	; U+0050
0006a0 0000
0006a1 e007
0006a2 1008
0006a3 1008
0006a4 1008
0006a5 1808
0006a6 e407
0006a7 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x18, 0x07, 0xE4, 0x00, 0x00	; U+0051
0006a8 0000
0006a9 f00f
0006aa 8008
0006ab 8008
0006ac c008
0006ad a008
0006ae 1007
0006af 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0xC0, 0x08, 0xA0, 0x07, 0x10, 0x00, 0x00	; U+0052
0006b0 0000
0006b1 1006
0006b2 1009
0006b3 1009
0006b4 9008
0006b5 9008
0006b6 6008
0006b7 0000                      .DB	0x00, 0x00, 0x06, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x90, 0x08, 0x90, 0x08, 0x60, 0x00, 0x00	; U+0053
0006b8 0000
0006b9 0008
0006ba 0008
0006bb 0008
0006bc f00f
0006bd 0008
0006be 0008
0006bf 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0F, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00	; U+0054
0006c0 0000
0006c1 e00f
0006c2 1000
0006c3 1000
0006c4 1000
0006c5 1000
0006c6 e00f
0006c7 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+0055
0006c8 0000
0006c9 000f
0006ca c000
0006cb 3000
0006cc 3000
0006cd c000
0006ce 000f
0006cf 0000                      .DB	0x00, 0x00, 0x0F, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x00	; U+0056
0006d0 0000
0006d1 f00f
0006d2 1000
0006d3 2000
0006d4 c000
0006d5 2000
0006d6 1000
0006d7 f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x20, 0x00, 0xC0, 0x00, 0x20, 0x00, 0x10, 0x0F, 0xF0	; U+0057
0006d8 0000
0006d9 300c
0006da 4002
0006db 8001
0006dc 8001
0006dd 4002
0006de 300c
0006df 0000                      .DB	0x00, 0x00, 0x0C, 0x30, 0x02, 0x40, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x0C, 0x30, 0x00, 0x00	; U+0058
0006e0 0000
0006e1 000c
0006e2 0002
0006e3 0001
0006e4 f000
0006e5 0001
0006e6 0002
0006e7 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+0059
0006e8 0000
0006e9 3008
0006ea 5008
0006eb 9008
0006ec 1009
0006ed 100a
0006ee 100c
0006ef 1008                      .DB	0x00, 0x00, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x0C, 0x10, 0x08, 0x10	; U+005A
0006f0 0000
0006f1 0000
0006f2 0000
0006f3 fc1f
0006f4 0410
0006f5 0410
0006f6 0410
0006f7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+005B
0006f8 0000
0006f9 000c
0006fa 0003
0006fb c000
0006fc 3000
0006fd 0c00
0006fe 0000
0006ff 0000                      .DB	0x00, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00	; U+005C
000700 0000
000701 0410
000702 0410
000703 0410
000704 fc1f
000705 0000
000706 0000
000707 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005D
000708 0000
000709 0002
00070a 0004
00070b 0008
00070c 0004
00070d 0002
00070e 0000
00070f 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005E
000710 0400
000711 0400
000712 0400
000713 0400
000714 0400
000715 0400
000716 0400
000717 0400                      .DB	0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04	; U+005F
000718 0000
000719 0000
00071a 0000
00071b 0010
00071c 0008
00071d 0004
00071e 0000
00071f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0060
000720 0000
000721 6000
000722 9002
000723 9002
000724 9002
000725 9002
000726 f001
000727 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+0061
000728 0000
000729 f01f
00072a 1001
00072b 1002
00072c 1002
00072d 1002
00072e e001
00072f 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0062
000730 0000
000731 e001
000732 1002
000733 1002
000734 1002
000735 1002
000736 2001
000737 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+0063
000738 0000
000739 e001
00073a 1002
00073b 1002
00073c 1002
00073d 2002
00073e f01f
00073f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x1F, 0xF0, 0x00, 0x00	; U+0064
000740 0000
000741 e001
000742 9002
000743 9002
000744 9002
000745 9002
000746 9001
000747 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+0065
000748 0000
000749 0002
00074a 0002
00074b f00f
00074c 0012
00074d 0012
00074e 0012
00074f 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x00, 0x00	; U+0066
000750 0000
000751 e001
000752 1202
000753 1202
000754 1202
000755 1202
000756 fc03
000757 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+0067
000758 0000
000759 f01f
00075a 0001
00075b 0002
00075c 0002
00075d 0002
00075e f001
00075f 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+0068
000760 0000
000761 0000
000762 1002
000763 1002
000764 f01b
000765 1000
000766 1000
000767 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x1B, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0069
000768 0000
000769 0000
00076a 0200
00076b 0202
00076c 0202
00076d fc1b
00076e 0000
00076f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1B, 0xFC, 0x00, 0x00, 0x00, 0x00	; U+006A
000770 0000
000771 f01f
000772 4000
000773 8000
000774 4001
000775 2002
000776 1000
000777 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x00, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x10, 0x00, 0x00	; U+006B
000778 0000
000779 0010
00077a 0010
00077b e01f
00077c 1000
00077d 1000
00077e 1000
00077f 0000                      .DB	0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+006c
000780 0000
000781 f003
000782 0002
000783 0002
000784 f001
000785 0002
000786 0002
000787 f001                      .DB	0x00, 0x00, 0x03, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0	; U+006d
000788 0000
000789 f003
00078a 0001
00078b 0002
00078c 0002
00078d 0002
00078e f001
00078f 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+006e
000790 0000
000791 e001
000792 1002
000793 1002
000794 1002
000795 1002
000796 e001
000797 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+006F
000798 0000
000799 fe03
00079a 1001
00079b 1002
00079c 1002
00079d 1002
00079e e001
00079f 0000                      .DB	0x00, 0x00, 0x03, 0xFE, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0070
0007a0 0000
0007a1 e001
0007a2 1002
0007a3 1002
0007a4 1002
0007a5 2002
0007a6 fe03
0007a7 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x03, 0xFE, 0x00, 0x00	; U+0071
0007a8 0000
0007a9 f003
0007aa 0001
0007ab 0002
0007ac 0002
0007ad 0002
0007ae 0001
0007af 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00	; U+0072
0007b0 0000
0007b1 1001
0007b2 9002
0007b3 9002
0007b4 5002
0007b5 5002
0007b6 2002
0007b7 0000                      .DB	0x00, 0x00, 0x01, 0x10, 0x02, 0x90, 0x02, 0x90, 0x02, 0x50, 0x02, 0x50, 0x02, 0x20, 0x00, 0x00	; U+0073
0007b8 0000
0007b9 0002
0007ba 0002
0007bb e00f
0007bc 1002
0007bd 1002
0007be 1002
0007bf 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x00, 0x00	; U+0074
0007c0 0000
0007c1 e003
0007c2 1000
0007c3 1000
0007c4 1000
0007c5 2000
0007c6 f003
0007c7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x03, 0xF0, 0x00, 0x00	; U+0075
0007c8 0000
0007c9 0003
0007ca c000
0007cb 3000
0007cc 3000
0007cd c000
0007ce 0003
0007cf 0000                      .DB	0x00, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00	; U+0076
0007d0 0000
0007d1 e003
0007d2 1000
0007d3 1000
0007d4 e001
0007d5 1000
0007d6 1000
0007d7 e003                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x01, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x03, 0xE0	; U+0077
0007d8 0000
0007d9 1002
0007da 2001
0007db c000
0007dc c000
0007dd 2001
0007de 1002
0007df 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x01, 0x20, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0x20, 0x02, 0x10, 0x00, 0x00	; U+0078
0007e0 0000
0007e1 e003
0007e2 1200
0007e3 1200
0007e4 1200
0007e5 2200
0007e6 fc03
0007e7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x22, 0x03, 0xFC, 0x00, 0x00	; U+0079
0007e8 0000
0007e9 1002
0007ea 3002
0007eb 5002
0007ec 9002
0007ed 1003
0007ee 1002
0007ef 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x02, 0x10, 0x00, 0x00	; U+007A
0007f0 0000
0007f1 0000
0007f2 8000
0007f3 8000
0007f4 780f
0007f5 0410
0007f6 0410
0007f7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x0F, 0x78, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+007B
0007f8 0000
0007f9 0000
0007fa 0000
0007fb 0000
0007fc fc3f
0007fd 0000
0007fe 0000
0007ff 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+007C
000800 0000
000801 0410
000802 0410
000803 780f
000804 8000
000805 8000
000806 0000
000807 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x0F, 0x78, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+007D
000808 0000
000809 0006
00080a 0008
00080b 0008
00080c 0004
00080d 0002
00080e 0002
00080f 000c                      .DB	0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+007E
000810 5455
000811 aaaa
000812 5455
000813 aaaa
000814 5455
000815 aaaa
000816 5455
000817 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000818 5455
000819 aaaa
00081a 5455
00081b aaaa
00081c 5455
00081d aaaa
00081e 5455
00081f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000820 5455
000821 aaaa
000822 5455
000823 aaaa
000824 5455
000825 aaaa
000826 5455
000827 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000828 5455
000829 aaaa
00082a 5455
00082b aaaa
00082c 5455
00082d aaaa
00082e 5455
00082f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000830 5455
000831 aaaa
000832 5455
000833 aaaa
000834 5455
000835 aaaa
000836 5455
000837 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000838 5455
000839 aaaa
00083a 5455
00083b aaaa
00083c 5455
00083d aaaa
00083e 5455
00083f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000840 5455
000841 aaaa
000842 5455
000843 aaaa
000844 5455
000845 aaaa
000846 5455
000847 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000848 5455
000849 aaaa
00084a 5455
00084b aaaa
00084c 5455
00084d aaaa
00084e 5455
00084f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000850 5455
000851 aaaa
000852 5455
000853 aaaa
000854 5455
000855 aaaa
000856 5455
000857 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000858 5455
000859 aaaa
00085a 5455
00085b aaaa
00085c 5455
00085d aaaa
00085e 5455
00085f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000860 5455
000861 aaaa
000862 5455
000863 aaaa
000864 5455
000865 aaaa
000866 5455
000867 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000868 5455
000869 aaaa
00086a 5455
00086b aaaa
00086c 5455
00086d aaaa
00086e 5455
00086f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000870 5455
000871 aaaa
000872 5455
000873 aaaa
000874 5455
000875 aaaa
000876 5455
000877 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000878 5455
000879 aaaa
00087a 5455
00087b aaaa
00087c 5455
00087d aaaa
00087e 5455
00087f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000880 5455
000881 aaaa
000882 5455
000883 aaaa
000884 5455
000885 aaaa
000886 5455
000887 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000888 5455
000889 aaaa
00088a 5455
00088b aaaa
00088c 5455
00088d aaaa
00088e 5455
00088f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000890 5455
000891 aaaa
000892 5455
000893 aaaa
000894 5455
000895 aaaa
000896 5455
000897 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000898 5455
000899 aaaa
00089a 5455
00089b aaaa
00089c 5455
00089d aaaa
00089e 5455
00089f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008a0 5455
0008a1 aaaa
0008a2 5455
0008a3 aaaa
0008a4 5455
0008a5 aaaa
0008a6 5455
0008a7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008a8 5455
0008a9 aaaa
0008aa 5455
0008ab aaaa
0008ac 5455
0008ad aaaa
0008ae 5455
0008af aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008b0 5455
0008b1 aaaa
0008b2 5455
0008b3 aaaa
0008b4 5455
0008b5 aaaa
0008b6 5455
0008b7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008b8 5455
0008b9 aaaa
0008ba 5455
0008bb aaaa
0008bc 5455
0008bd aaaa
0008be 5455
0008bf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008c0 5455
0008c1 aaaa
0008c2 5455
0008c3 aaaa
0008c4 5455
0008c5 aaaa
0008c6 5455
0008c7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008c8 5455
0008c9 aaaa
0008ca 5455
0008cb aaaa
0008cc 5455
0008cd aaaa
0008ce 5455
0008cf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008d0 5455
0008d1 aaaa
0008d2 5455
0008d3 aaaa
0008d4 5455
0008d5 aaaa
0008d6 5455
0008d7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008d8 5455
0008d9 aaaa
0008da 5455
0008db aaaa
0008dc 5455
0008dd aaaa
0008de 5455
0008df aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008e0 5455
0008e1 aaaa
0008e2 5455
0008e3 aaaa
0008e4 5455
0008e5 aaaa
0008e6 5455
0008e7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008e8 5455
0008e9 aaaa
0008ea 5455
0008eb aaaa
0008ec 5455
0008ed aaaa
0008ee 5455
0008ef aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008f0 5455
0008f1 aaaa
0008f2 5455
0008f3 aaaa
0008f4 5455
0008f5 aaaa
0008f6 5455
0008f7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008f8 5455
0008f9 aaaa
0008fa 5455
0008fb aaaa
0008fc 5455
0008fd aaaa
0008fe 5455
0008ff aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000900 5455
000901 aaaa
000902 5455
000903 aaaa
000904 5455
000905 aaaa
000906 5455
000907 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000908 5455
000909 aaaa
00090a 5455
00090b aaaa
00090c 5455
00090d aaaa
00090e 5455
00090f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000910 5455
000911 aaaa
000912 5455
000913 aaaa
000914 5455
000915 aaaa
000916 5455
000917 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000918 0000
000919 0000
00091a 0000
00091b 0000
00091c 0000
00091d 0000
00091e 0000
00091f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A0
000920 0000
000921 0000
000922 0000
000923 3e03
000924 0000
000925 0000
000926 0000
000927 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A1
000928 0000
000929 c003
00092a 2004
00092b 2004
00092c f81f
00092d 2004
00092e 2004
00092f 4002                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x04, 0x20, 0x1F, 0xF8, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40	; U+00A2
000930 0000
000931 1001
000932 2001
000933 e007
000934 2009
000935 1009
000936 1008
000937 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
000938 0000
000939 2004
00093a c003
00093b 4002
00093c 4002
00093d c003
00093e 2004
00093f 0000                      .DB	0x00, 0x00, 0x04, 0x20, 0x03, 0xC0, 0x02, 0x40, 0x02, 0x40, 0x03, 0xC0, 0x04, 0x20, 0x00, 0x00	; U+00A4
000940 0000
000941 0008
000942 4005
000943 4003
000944 f001
000945 4003
000946 4005
000947 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x05, 0x40, 0x03, 0x40, 0x01, 0xF0, 0x03, 0x40, 0x05, 0x40, 0x08, 0x00	; U+00A5
000948 0000
000949 0000
00094a 0000
00094b 0000
00094c 3c0f
00094d 0000
00094e 0000
00094f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A6
000950 5455
000951 aaaa
000952 5455
000953 aaaa
000954 5455
000955 aaaa
000956 5455
000957 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000958 0000
000959 0000
00095a 0060
00095b 0000
00095c 0000
00095d 0060
00095e 0000
00095f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A8
000960 0000
000961 c003
000962 2004
000963 9009
000964 500a
000965 500a
000966 2004
000967 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x09, 0x90, 0x0A, 0x50, 0x0A, 0x50, 0x04, 0x20, 0x03, 0xC0	; U+00A9
000968 5455
000969 aaaa
00096a 5455
00096b aaaa
00096c 5455
00096d aaaa
00096e 5455
00096f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000970 0000
000971 8000
000972 4001
000973 2002
000974 9004
000975 4001
000976 2002
000977 1004                      .DB	0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x90, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10	; U+00AB
000978 5455
000979 aaaa
00097a 5455
00097b aaaa
00097c 5455
00097d aaaa
00097e 5455
00097f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000980 0000
000981 8000
000982 8000
000983 8000
000984 8000
000985 8000
000986 8000
000987 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00AD
000988 5455
000989 aaaa
00098a 5455
00098b aaaa
00098c 5455
00098d aaaa
00098e 5455
00098f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000990 5455
000991 aaaa
000992 5455
000993 aaaa
000994 5455
000995 aaaa
000996 5455
000997 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000998 0000
000999 0007
00099a 8008
00099b 8008
00099c 8008
00099d 0007
00099e 0000
00099f 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
0009a0 5455
0009a1 aaaa
0009a2 5455
0009a3 aaaa
0009a4 5455
0009a5 aaaa
0009a6 5455
0009a7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009a8 5455
0009a9 aaaa
0009aa 5455
0009ab aaaa
0009ac 5455
0009ad aaaa
0009ae 5455
0009af aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009b0 5455
0009b1 aaaa
0009b2 5455
0009b3 aaaa
0009b4 5455
0009b5 aaaa
0009b6 5455
0009b7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009b8 5455
0009b9 aaaa
0009ba 5455
0009bb aaaa
0009bc 5455
0009bd aaaa
0009be 5455
0009bf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009c0 5455
0009c1 aaaa
0009c2 5455
0009c3 aaaa
0009c4 5455
0009c5 aaaa
0009c6 5455
0009c7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009c8 5455
0009c9 aaaa
0009ca 5455
0009cb aaaa
0009cc 5455
0009cd aaaa
0009ce 5455
0009cf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009d0 5455
0009d1 aaaa
0009d2 5455
0009d3 aaaa
0009d4 5455
0009d5 aaaa
0009d6 5455
0009d7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009d8 0000
0009d9 0000
0009da 0200
0009db 0200
0009dc 0c00
0009dd 0000
0009de 0000
0009df 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B8
0009e0 5455
0009e1 aaaa
0009e2 5455
0009e3 aaaa
0009e4 5455
0009e5 aaaa
0009e6 5455
0009e7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009e8 5455
0009e9 aaaa
0009ea 5455
0009eb aaaa
0009ec 5455
0009ed aaaa
0009ee 5455
0009ef aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009f0 0000
0009f1 1004
0009f2 2002
0009f3 4001
0009f4 9004
0009f5 2002
0009f6 4001
0009f7 8000                      .DB	0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x04, 0x90, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80	; U+00BB
0009f8 5455
0009f9 aaaa
0009fa 5455
0009fb aaaa
0009fc 5455
0009fd aaaa
0009fe 5455
0009ff aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000a00 5455
000a01 aaaa
000a02 5455
000a03 aaaa
000a04 5455
000a05 aaaa
000a06 5455
000a07 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000a08 5455
000a09 aaaa
000a0a 5455
000a0b aaaa
000a0c 5455
000a0d aaaa
000a0e 5455
000a0f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000a10 0000
000a11 0000
000a12 0c00
000a13 1200
000a14 2203
000a15 0200
000a16 0400
000a17 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x12, 0x03, 0x22, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00	; U+00BF
000a18 0000
000a19 7000
000a1a c043
000a1b 402c
000a1c 400c
000a1d c003
000a1e 7000
000a1f 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x43, 0xC0, 0x2C, 0x40, 0x0C, 0x40, 0x03, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C0
000a20 0000
000a21 7000
000a22 c003
000a23 400c
000a24 402c
000a25 c043
000a26 7000
000a27 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x2C, 0x40, 0x43, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C1
000a28 0000
000a29 7000
000a2a c023
000a2b 404c
000a2c 404c
000a2d c023
000a2e 7000
000a2f 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x23, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x23, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C2
000a30 0000
000a31 7020
000a32 c043
000a33 404c
000a34 402c
000a35 c023
000a36 7040
000a37 0000                      .DB	0x00, 0x00, 0x20, 0x70, 0x43, 0xC0, 0x4C, 0x40, 0x2C, 0x40, 0x23, 0xC0, 0x40, 0x70, 0x00, 0x00	; U+00C3
000a38 0000
000a39 7000
000a3a c063
000a3b 400c
000a3c 400c
000a3d c063
000a3e 7000
000a3f 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x63, 0xC0, 0x0C, 0x40, 0x0C, 0x40, 0x63, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C4
000a40 0000
000a41 7000
000a42 c033
000a43 404c
000a44 404c
000a45 c033
000a46 7000
000a47 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x33, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x33, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C5
000a48 0000
000a49 7000
000a4a c003
000a4b 400c
000a4c f00f
000a4d 1009
000a4e 1009
000a4f 1008                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10	; U+00C6
000a50 0000
000a51 c003
000a52 2204
000a53 1208
000a54 1c08
000a55 1008
000a56 1008
000a57 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x22, 0x08, 0x12, 0x08, 0x1C, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C7
000a58 0000
000a59 f00f
000a5a 1049
000a5b 1029
000a5c 1009
000a5d 1009
000a5e 1008
000a5f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x49, 0x10, 0x29, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C8
000a60 0000
000a61 f00f
000a62 1009
000a63 1009
000a64 1029
000a65 1049
000a66 1008
000a67 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x29, 0x10, 0x49, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C9
000a68 0000
000a69 f00f
000a6a 1029
000a6b 1049
000a6c 1049
000a6d 1029
000a6e 1008
000a6f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x29, 0x10, 0x49, 0x10, 0x49, 0x10, 0x29, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CA
000a70 0000
000a71 f00f
000a72 1069
000a73 1009
000a74 1009
000a75 1069
000a76 1008
000a77 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x69, 0x10, 0x09, 0x10, 0x09, 0x10, 0x69, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CB
000a78 0000
000a79 0000
000a7a 1008
000a7b 1048
000a7c f02f
000a7d 1008
000a7e 1008
000a7f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x48, 0x10, 0x2F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CC
000a80 0000
000a81 0000
000a82 1008
000a83 1008
000a84 f02f
000a85 1048
000a86 1008
000a87 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x2F, 0xF0, 0x48, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CD
000a88 0000
000a89 0000
000a8a 1008
000a8b 1028
000a8c f04f
000a8d 1028
000a8e 1008
000a8f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x28, 0x10, 0x4F, 0xF0, 0x28, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CE
000a90 0000
000a91 0000
000a92 1008
000a93 1068
000a94 f00f
000a95 1068
000a96 1008
000a97 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x68, 0x10, 0x0F, 0xF0, 0x68, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CF
000a98 0000
000a99 0001
000a9a f00f
000a9b 1009
000a9c 1009
000a9d 1008
000a9e 2004
000a9f c003                      .DB	0x00, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D0
000aa0 0000
000aa1 f02f
000aa2 0044
000aa3 0042
000aa4 0021
000aa5 8020
000aa6 f04f
000aa7 0000                      .DB	0x00, 0x00, 0x2F, 0xF0, 0x44, 0x00, 0x42, 0x00, 0x21, 0x00, 0x20, 0x80, 0x4F, 0xF0, 0x00, 0x00	; U+00D1
000aa8 0000
000aa9 c003
000aaa 2004
000aab 1048
000aac 1028
000aad 1008
000aae 2004
000aaf c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x48, 0x10, 0x28, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D2
000ab0 0000
000ab1 c003
000ab2 2004
000ab3 1008
000ab4 1028
000ab5 1048
000ab6 2004
000ab7 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x28, 0x10, 0x48, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D3
000ab8 0000
000ab9 c003
000aba 2004
000abb 1028
000abc 1048
000abd 1028
000abe 2004
000abf c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x28, 0x10, 0x48, 0x10, 0x28, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D4
000ac0 0000
000ac1 c003
000ac2 2024
000ac3 1048
000ac4 1048
000ac5 1028
000ac6 2024
000ac7 c043                      .DB	0x00, 0x00, 0x03, 0xC0, 0x24, 0x20, 0x48, 0x10, 0x48, 0x10, 0x28, 0x10, 0x24, 0x20, 0x43, 0xC0	; U+00D5
000ac8 0000
000ac9 c003
000aca 2064
000acb 1008
000acc 1008
000acd 1008
000ace 2064
000acf c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x64, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x64, 0x20, 0x03, 0xC0	; U+00D6
000ad0 0000
000ad1 0000
000ad2 2002
000ad3 4001
000ad4 8000
000ad5 4001
000ad6 2002
000ad7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x00	; U+00D7
000ad8 0000
000ad9 c803
000ada 3004
000adb 5008
000adc 9009
000add 100a
000ade 200c
000adf c013                      .DB	0x00, 0x00, 0x03, 0xC8, 0x04, 0x30, 0x08, 0x50, 0x09, 0x90, 0x0A, 0x10, 0x0C, 0x20, 0x13, 0xC0	; U+00D8
000ae0 0000
000ae1 e00f
000ae2 1040
000ae3 1020
000ae4 1000
000ae5 1000
000ae6 e00f
000ae7 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x40, 0x10, 0x20, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00D9
000ae8 0000
000ae9 e00f
000aea 1000
000aeb 1000
000aec 1020
000aed 1040
000aee e00f
000aef 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x20, 0x10, 0x40, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DA
000af0 0000
000af1 e00f
000af2 1020
000af3 1040
000af4 1040
000af5 1020
000af6 e00f
000af7 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x20, 0x10, 0x40, 0x10, 0x40, 0x10, 0x20, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DB
000af8 0000
000af9 e00f
000afa 1060
000afb 1000
000afc 1000
000afd 1060
000afe e00f
000aff 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x60, 0x10, 0x00, 0x10, 0x00, 0x10, 0x60, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DC
000b00 0000
000b01 000c
000b02 0062
000b03 0001
000b04 f000
000b05 0001
000b06 0062
000b07 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x62, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x62, 0x00, 0x0C, 0x00	; U+00DD
000b08 0000
000b09 f00f
000b0a 2004
000b0b 2004
000b0c 2004
000b0d 2004
000b0e c003
000b0f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+00DE
000b10 0000
000b11 f007
000b12 0008
000b13 0008
000b14 1009
000b15 100b
000b16 e004
000b17 0000                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x09, 0x10, 0x0B, 0x10, 0x04, 0xE0, 0x00, 0x00	; U+00DF
000b18 0000
000b19 6000
000b1a 9012
000b1b 900a
000b1c 9002
000b1d 9002
000b1e f001
000b1f 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E0
000b20 0000
000b21 6000
000b22 9002
000b23 9002
000b24 900a
000b25 9012
000b26 f001
000b27 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E1
000b28 0000
000b29 6000
000b2a 900a
000b2b 9012
000b2c 9012
000b2d 900a
000b2e f001
000b2f 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E2
000b30 0000
000b31 6008
000b32 9012
000b33 9012
000b34 900a
000b35 900a
000b36 f011
000b37 0000                      .DB	0x00, 0x00, 0x08, 0x60, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x0A, 0x90, 0x11, 0xF0, 0x00, 0x00	; U+00E3
000b38 0000
000b39 6000
000b3a 901a
000b3b 9002
000b3c 9002
000b3d 901a
000b3e f001
000b3f 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E4
000b40 0000
000b41 6000
000b42 9032
000b43 904a
000b44 904a
000b45 9032
000b46 f001
000b47 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x32, 0x90, 0x4A, 0x90, 0x4A, 0x90, 0x32, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E5
000b48 0000
000b49 6000
000b4a 9002
000b4b 9002
000b4c e001
000b4d 9002
000b4e 9002
000b4f 9001                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90	; U+00E6
000b50 0000
000b51 e001
000b52 1202
000b53 1202
000b54 1c02
000b55 1002
000b56 2001
000b57 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x1C, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+00E7
000b58 0000
000b59 e001
000b5a 9012
000b5b 900a
000b5c 9002
000b5d 9002
000b5e 9001
000b5f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E8
000b60 0000
000b61 e001
000b62 9002
000b63 9002
000b64 900a
000b65 9012
000b66 9001
000b67 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E9
000b68 0000
000b69 e001
000b6a 900a
000b6b 9012
000b6c 9012
000b6d 900a
000b6e 9001
000b6f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EA
000b70 0000
000b71 e001
000b72 901a
000b73 9002
000b74 9002
000b75 901a
000b76 9001
000b77 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EB
000b78 0000
000b79 0000
000b7a 1012
000b7b 100a
000b7c f003
000b7d 1000
000b7e 1000
000b7f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x12, 0x10, 0x0A, 0x10, 0x03, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EC
000b80 0000
000b81 0000
000b82 1002
000b83 1002
000b84 f00b
000b85 1010
000b86 1000
000b87 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x0B, 0xF0, 0x10, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00ED
000b88 0000
000b89 0000
000b8a 100a
000b8b 1012
000b8c f013
000b8d 1008
000b8e 1000
000b8f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x0A, 0x10, 0x12, 0x10, 0x13, 0xF0, 0x08, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EE
000b90 0000
000b91 0000
000b92 101a
000b93 1002
000b94 f003
000b95 1018
000b96 1000
000b97 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1A, 0x10, 0x02, 0x10, 0x03, 0xF0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EF
000b98 0000
000b99 e001
000b9a 100a
000b9b 102a
000b9c 101a
000b9d 1016
000b9e e021
000b9f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x2A, 0x10, 0x1A, 0x10, 0x16, 0x10, 0x21, 0xE0, 0x00, 0x00	; U+00F0
000ba0 0000
000ba1 f00b
000ba2 0012
000ba3 0012
000ba4 000a
000ba5 000a
000ba6 f011
000ba7 0000                      .DB	0x00, 0x00, 0x0B, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x11, 0xF0, 0x00, 0x00	; U+00F1
000ba8 0000
000ba9 e001
000baa 1012
000bab 100a
000bac 1002
000bad 1002
000bae e001
000baf 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x10, 0x0A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F2
000bb0 0000
000bb1 e001
000bb2 1002
000bb3 1002
000bb4 100a
000bb5 1012
000bb6 e001
000bb7 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x0A, 0x10, 0x12, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F3
000bb8 0000
000bb9 e001
000bba 100a
000bbb 1012
000bbc 1012
000bbd 100a
000bbe e001
000bbf 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F4
000bc0 0000
000bc1 e009
000bc2 1012
000bc3 1012
000bc4 100a
000bc5 100a
000bc6 e011
000bc7 0000                      .DB	0x00, 0x00, 0x09, 0xE0, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x0A, 0x10, 0x11, 0xE0, 0x00, 0x00	; U+00F5
000bc8 0000
000bc9 e001
000bca 101a
000bcb 1002
000bcc 1002
000bcd 101a
000bce e001
000bcf 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x1A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F6
000bd0 0000
000bd1 8000
000bd2 8000
000bd3 b006
000bd4 b006
000bd5 8000
000bd6 8000
000bd7 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x06, 0xB0, 0x06, 0xB0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00F7
000bd8 0000
000bd9 e801
000bda 3002
000bdb 5002
000bdc 9002
000bdd 1003
000bde e005
000bdf 0000                      .DB	0x00, 0x00, 0x01, 0xE8, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x05, 0xE0, 0x00, 0x00	; U+00F8
000be0 0000
000be1 e003
000be2 1010
000be3 1008
000be4 1000
000be5 1000
000be6 f003
000be7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x10, 0x10, 0x08, 0x10, 0x00, 0x10, 0x00, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00F9
000be8 0000
000be9 e003
000bea 1000
000beb 1000
000bec 1008
000bed 1010
000bee f003
000bef 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x08, 0x10, 0x10, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FA
000bf0 0000
000bf1 e003
000bf2 1008
000bf3 1010
000bf4 1010
000bf5 1008
000bf6 f003
000bf7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FB
000bf8 0000
000bf9 e003
000bfa 1018
000bfb 1000
000bfc 1000
000bfd 1018
000bfe f003
000bff 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x10, 0x18, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FC
000c00 0000
000c01 e003
000c02 1200
000c03 1200
000c04 1208
000c05 1210
000c06 fc03
000c07 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x08, 0x12, 0x10, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FD
000c08 0000
000c09 fe1f
000c0a 1002
000c0b 1002
000c0c 1002
000c0d 1002
000c0e e001
000c0f 0000                      .DB	0x00, 0x00, 0x1F, 0xFE, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00FE
000c10 0000
000c11 e003
000c12 1218
000c13 1200
000c14 1200
000c15 1218
000c16 fc03
000c17 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x12, 0x00, 0x12, 0x00, 0x12, 0x18, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FF
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32U4" register use summary:
x  :  40 y  :   0 z  :  11 r0 :  12 r1 :   9 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 277 r17:  30 r18:  32 r19:  12 r20:   3 
r21:  28 r22:  13 r23:   0 r24:   5 r25:   5 r26:  58 r27:  55 r28:   0 
r29:   0 r30:  55 r31:  55 
Registers used: 17 out of 35 (48.6%)

"ATmega32U4" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   9 adiw  :   5 and   :   0 
andi  :   5 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  31 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :  16 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  12 cbi   :   6 cbr   :   0 
clc   :   0 clh   :   0 cli   :   1 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   0 cpc   :   0 
cpi   :  35 cpse  :   0 dec   :  17 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   8 inc   :   1 jmp   :   0 
ld    :  12 ldd   :   0 ldi   : 186 lds   :   3 lpm   :   7 lsl   :   3 
lsr   :  15 mov   :   5 movw  :   1 mul   :   1 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   2 ori   :   5 out   :  24 pop   : 111 
push  : 111 rcall :  62 ret   :  36 reti  :   6 rjmp  :  45 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  14 sbic  :   0 sbis  :   0 
sbiw  :   1 sbr   :   0 sbrc  :   0 sbrs  :   5 sec   :   0 seh   :   0 
sei   :   2 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :  34 std   :   0 sts   :  14 
sub   :   2 subi  :   1 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 41 out of 113 (36.3%)

"ATmega32U4" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001830   1772   4272   6044   32768  18.4%
[.dseg] 0x000100 0x000206      0      6      6    2560   0.2%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
